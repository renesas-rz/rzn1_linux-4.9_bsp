From cd03a1e7bc33f37faba8e50cc23c2da1401723b5 Mon Sep 17 00:00:00 2001
From: Michel Pollet <michel.pollet@bp.renesas.com>
Date: Wed, 25 Nov 2015 12:03:55 +0000
Subject: [PATCH] rzn1: USB Function/device driver

This implements a driver for the USB function block,
it has been tested with the various configuration of the 'gadget'
functions and appears to be functional, abeit without support for
the DMA block for the moment.

Signed-off-by: Michel Pollet <michel.pollet@bp.renesas.com>
---
 .../devicetree/bindings/usb/renesas,usbf.txt       |   80 ++
 drivers/usb/gadget/udc/Kconfig                     |   11 +
 drivers/usb/gadget/udc/Makefile                    |    2 +
 drivers/usb/gadget/udc/usbf-renesas-ep0.c          |  441 ++++++++
 drivers/usb/gadget/udc/usbf-renesas-epn.c          |  449 ++++++++
 drivers/usb/gadget/udc/usbf-renesas.c              | 1114 ++++++++++++++++++++
 drivers/usb/gadget/udc/usbf-renesas.h              |  614 +++++++++++
 7 files changed, 2711 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/usb/renesas,usbf.txt
 create mode 100644 drivers/usb/gadget/udc/usbf-renesas-ep0.c
 create mode 100644 drivers/usb/gadget/udc/usbf-renesas-epn.c
 create mode 100644 drivers/usb/gadget/udc/usbf-renesas.c
 create mode 100644 drivers/usb/gadget/udc/usbf-renesas.h

diff --git a/Documentation/devicetree/bindings/usb/renesas,usbf.txt b/Documentation/devicetree/bindings/usb/renesas,usbf.txt
new file mode 100644
index 0000000..a884e22
--- /dev/null
+++ b/Documentation/devicetree/bindings/usb/renesas,usbf.txt
@@ -0,0 +1,80 @@
+Required properties :
+ - compatible : Should be "renesas,usbf".
+ - reg : Offset and length of the register set for the device.
+ - clock-names: needs to be "axi".
+ - clocks: must refer to the clock used by the IP.
+ - interrupts: Should list the two interrupts needed by the IP
+
+Optional Properties:
+ - renesas,sram-conf[,<gadget-name>]
+	This property allows you to specify the SRAM allocated per
+	endpoint types, OR the SRAM allocated for each endpoint
+	individually.
+	In the first instance, if you specify a 3 element array, this
+	specifies the number of USB packets per endpoint /type/, for
+	example:
+		renesas,sram-ep-packets = <4 3 0>;
+	Will allocate 4 packets (of 512, implicitly) to the bulk
+	endpoints (first element); 3 packets (or whatever size the
+	descriptor specifies) to the interrupt endpoints, and the default
+	value (which is 2, incidentally) of packets to the isochronous
+	endpoints.
+	In the second instance, you can specify the number of packets
+	per endpoint by passing an array of more than 3 elements:
+		renesas,sram-conf = <
+			4 4 0 0 0	/* -bulk endpoints */
+			4 0 0 0		/* -int endpoints */
+			0 0 0 0 0 0>;	/* -iso endpoints */
+	In this case, you can specify the size to the endpoints you
+	know are being used.
+	Note that you can tie a memory configuration for a particular
+	gadget configuration; the driver will first look for the property
+	name concatenated with the currently configured gadget before
+	doing a fallback on the generic name. Thus:
+		renesas,sram-conf,g_ether = <6 2 0>;
+		renesas,sram-conf = <2 8 0>;
+	This is a valid declaration providing a configuration for the
+	RNDIS g_ether driver, and another configuration for any other
+	cases/gadget.
+
+ - renesas,sram-size
+	The renesas IP can be configured with variable amount of SRAM,
+	variable type/number of endpoints, and some of them disabled.
+	The sram-size property is the only one that cannot be inferred
+	by probing, so this properly allows you to specify it as per
+	your device configuration.
+	The SRAM size is just used to make sure you don't allocate too
+	much using the renesas,sram-conf property, it can be left out,
+	but doing so will prevent any warning from being emitted, and
+	that could result in silent failure.
+	NOTE: The ram size value is the number of 32 bits words in SRAM,
+	      and NOT a byte value.
+		renesas,sram-size = <5024>;
+
+ - renesas,dma-threshold
+	Specifies the packet size at below which we don't even attempt
+	to do a DMA transfer. The DMA introduces some latency as the IRQ
+	needs to be routed back to the driver, so a small packet size with DMA
+	might take longer to transfer than sending it using plain PIO.
+	The threshold is by default 64, however, it was not set using any
+	measurement, so the value probably should be measured using proper
+	empirical testing for the use you make of the driver.
+
+Example:
+	usbf: usbf@RZN1_USB_DEV_BASE {
+		compatible = "renesas,usbf";
+		reg = <RZN1_USB_DEV_BASE RZN1_USB_DEV_SIZE>;
+		interrupts =
+			<GIC_SPI
+				RZN1_IRQ_USBF_EPC IRQ_TYPE_LEVEL_HIGH>,
+			<GIC_SPI
+				RZN1_IRQ_USBF IRQ_TYPE_LEVEL_HIGH>;
+		clock-names = "axi";
+		clocks = <&clk_fw_usb_f>;
+
+		renesas,sram-size = <5024>; /* 32 bits words */
+		renesas,sram-conf,g_ether = <6 6 0 0 0 4>;
+		renesas,sram-conf,g_mass_storage = <8 8 0 0 0 0>;
+		renesas,dma-threshold = <64>;
+		status = "okay";
+	};
diff --git a/drivers/usb/gadget/udc/Kconfig b/drivers/usb/gadget/udc/Kconfig
index 658b8da..2465d6d9 100644
--- a/drivers/usb/gadget/udc/Kconfig
+++ b/drivers/usb/gadget/udc/Kconfig
@@ -140,6 +140,17 @@ config USB_PXA25X
 	   dynamically linked module called "pxa25x_udc" and force all
 	   gadget drivers to also be dynamically linked.
 
+config USBF_RENESAS
+	tristate "Renesas USB Function Peripheral Block (RZ/N1)"
+	depends on ARCH_RZN1
+	help
+	   Renesas RZ/N1 USB function block. Has integrated DMA, 16
+	   endpoints. The pretty name for this IP is
+	   "NPPFAHBUSB2HOSTFUNCV31,41". Yes, it is.
+
+	   Say "y" to link the driver statically, or "m" to build a
+	   dynamically linked module called "usbf_renesas".
+
 # if there's only one gadget driver, using only two bulk endpoints,
 # don't waste memory for the other endpoints
 config USB_PXA25X_SMALL
diff --git a/drivers/usb/gadget/udc/Makefile b/drivers/usb/gadget/udc/Makefile
index 98e74ed..ce084b1 100644
--- a/drivers/usb/gadget/udc/Makefile
+++ b/drivers/usb/gadget/udc/Makefile
@@ -37,3 +37,5 @@ obj-$(CONFIG_USB_MV_U3D)	+= mv_u3d_core.o
 obj-$(CONFIG_USB_GR_UDC)	+= gr_udc.o
 obj-$(CONFIG_USB_GADGET_XILINX)	+= udc-xilinx.o
 obj-$(CONFIG_USB_BDC_UDC)	+= bdc/
+obj-$(CONFIG_USBF_RENESAS)	+= usbf-renesas.o
+obj-$(CONFIG_USBF_RENESAS)	+= usbf-renesas-ep0.o usbf-renesas-epn.o
diff --git a/drivers/usb/gadget/udc/usbf-renesas-ep0.c b/drivers/usb/gadget/udc/usbf-renesas-ep0.c
new file mode 100644
index 0000000..06e0b49
--- /dev/null
+++ b/drivers/usb/gadget/udc/usbf-renesas-ep0.c
@@ -0,0 +1,441 @@
+/*
+ * Renesas RZ/N1 USB Device usb gadget driver
+ *
+ * Copyright 2015 Renesas Electronics Europe Ltd.
+ * Author: Michel Pollet <michel.pollet@bp.renesas.com>,<buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/iopoll.h>
+#include <linux/kernel.h>
+#include "usbf-renesas.h"
+
+/*
+ * Endpoint 0 callbacks
+ */
+
+static int usbf_ep0_flush_buffer(
+	struct f_regs_ep0 *ep_reg,
+	uint32_t bits)
+{
+	int res = 100000;
+
+	if ((readl(&ep_reg->status) & bits) == bits)
+		return res;
+
+	writel(readl(&ep_reg->control) | D_EP0_BCLR, &ep_reg->control);
+
+	while (res-- && ((readl(&ep_reg->status) & bits) != bits))
+		;
+
+	if (!res)
+		printk("%s timeout on buffer clear!\n", __func__);
+
+	return res;
+}
+
+static void usbf_ep0_clear_inak(
+	struct f_regs_ep0 *ep_reg)
+{
+	writel((readl(&ep_reg->control)|D_EP0_INAK_EN) & ~D_EP0_INAK,
+	       &ep_reg->control);
+}
+
+static void usbf_ep0_clear_onak(
+	struct f_regs_ep0 *ep_reg)
+{
+	writel((readl(&ep_reg->control)) & ~D_EP0_ONAK, &ep_reg->control);
+}
+
+static void usbf_ep0_stall(
+	struct f_regs_ep0 *ep_reg)
+{
+	writel(readl(&ep_reg->control) | D_EP0_STL, &ep_reg->control);
+}
+
+static int usbf_ep0_enable(
+	struct f_endpoint *ep)
+{
+	struct f_drv *chip = ep->chip;
+	struct f_regs_ep0 *ep_reg = &chip->regs->ep0;
+
+	writel(D_EP0_INAK_EN | D_EP0_BCLR, &ep_reg->control);
+	writel(D_EP0_SETUP_EN | D_EP0_STG_START_EN |
+	       D_EP0_OUT_EN,
+	       &ep_reg->int_enable);
+	return 0;
+}
+
+static void usbf_ep0_reset(
+	struct f_endpoint *ep)
+{
+	struct f_drv *chip = ep->chip;
+	struct f_regs_ep0 *ep_reg = &chip->regs->ep0;
+
+	writel(readl(&ep_reg->control) | D_EP0_BCLR, &ep_reg->control);
+}
+
+static int usbf_ep0_send1(
+	struct f_endpoint *ep,
+	uint32_t *src,
+	int reqlen)
+{
+	struct f_drv *chip = ep->chip;
+	struct f_regs_ep0 *ep_reg = &chip->regs->ep0;
+	uint32_t control;
+	int w, len, err;
+	uint32_t val;
+	int pkt_words = reqlen / sizeof(*src);
+
+	/* Wait until there is space to write the pkt */
+	err = readl_poll_timeout(&ep_reg->status, val, (val & D_EP0_IN_EMPTY),
+			0, 10000);
+	if (err)
+		return -ETIMEDOUT;
+
+	/* Note, we don't care about endianness here, as the IP
+	 * and the core will have the same layout anyway, so we
+	 * can happily ignore it */
+	for (w = 0; w < pkt_words; w++)
+		writel(*src++, &ep_reg->write);
+
+	control = readl(&ep_reg->control);
+
+	/* if we have stray bytes, write them off too, and mark the
+	 * control registers so it knows only 1,2,3 bytes are valid in
+	 * the last write we made */
+	len = reqlen & (sizeof(*src) - 1);
+	if (len) {
+		writel(*src, &ep_reg->write);
+		control |= (len << 5);
+	}
+
+	writel(control | D_EP0_DEND, &ep_reg->control);
+
+	return 0;
+}
+
+static int usbf_ep0_send(
+	struct f_endpoint *ep,
+	struct f_req *req)
+{
+	struct f_drv *chip = ep->chip;
+	struct f_regs_ep0 *ep_reg = &chip->regs->ep0;
+
+	/* Special handling for internally generated NULL packets */
+	if (!req) {
+		writel(readl(&ep_reg->control) | D_EP0_DEND, &ep_reg->control);
+		return 0;
+	}
+
+	if (req->req.length) {
+		void *src = req->req.buf;
+		int bytes = req->req.length;
+		int maxpkt_bytes = ep->ep.maxpacket;
+		int ret;
+
+		while (bytes > 0) {
+			int pkt_bytes = min(bytes, maxpkt_bytes);
+
+			ret = usbf_ep0_send1(ep, src, pkt_bytes);
+			if (ret < 0) {
+				req->req.status = ret;
+				return ret;
+			}
+
+			bytes -= pkt_bytes;
+			src += pkt_bytes;
+		}
+		req->req.actual = req->req.length;
+		req->req.status = 0;
+	}
+
+	/* UDC asking for a ZLP to follow? */
+	if (req->req.length == 0 || req->req.zero)
+		req->req.status = usbf_ep0_send1(ep, NULL, 0);
+
+	TRACERQ(req, "%s[%d][%3d] sent %d\n", __func__,
+		ep->id, req->seq, req->req.length);
+
+	return req->req.status;
+}
+
+/*
+ * This can be called repeatedly until the request is done
+ */
+static int usbf_ep0_recv(
+	struct f_endpoint *ep,
+	struct f_req *req)
+{
+	return req->req.status;
+}
+
+static void usbf_ep0_out_isr(
+	struct f_endpoint *ep,
+	struct f_req *req)
+{
+	struct f_regs_ep0 *ep_reg = &ep->chip->regs->ep0;
+	uint32_t reqlen = readl(&ep_reg->length);
+	int len = reqlen;
+	uint32_t *buf  = req->req.buf + req->req.actual;
+
+	TRACEEP(ep, "%s[%3d] size %d (%d/%d)\n", __func__, req->seq, len,
+	      req->req.actual, req->req.length);
+	while (len > 0) {
+		*buf++ = readl(&ep_reg->read);
+		len -= 4;
+	}
+	req->req.actual += reqlen;
+
+	if (reqlen != usb_endpoint_maxp(ep->desc))
+		req->req.status = 0;
+}
+
+
+/*
+ * result of setup packet
+ */
+#define CX_IDLE		0
+#define CX_FINISH	1
+#define CX_STALL	2
+
+static void usbf_ep0_setup(
+	struct f_endpoint *ep,
+	struct usb_ctrlrequest *ctrl)
+{
+	int ret = CX_IDLE;
+	struct f_drv *chip = ep->chip;
+	struct f_regs_ep0 *ep_reg = &chip->regs->ep0;
+	uint16_t value = ctrl->wValue & 0xff;
+
+	if (ctrl->bRequestType & USB_DIR_IN)
+		ep->desc->bEndpointAddress = USB_DIR_IN;
+	else
+		ep->desc->bEndpointAddress = USB_DIR_OUT;
+
+	/* TODO:
+	 * This is mandatory, as for the moment at least, we never get an
+	 * interrupt/status flag indicating the speed has changed. And without
+	 * a speed change flag, the gadget upper layer is incapable of finding
+	 * a valid configuration */
+	if (readl(&chip->regs->status) & D_USB_SPEED_MODE)
+		chip->gadget.speed = USB_SPEED_HIGH;
+	else
+		chip->gadget.speed = USB_SPEED_FULL;
+
+	if ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {
+		switch (ctrl->bRequest) {
+		case USB_REQ_SET_CONFIGURATION:
+			TRACEEP(ep, "usbf: set_cfg(%d)\n", value);
+			if (!value) {
+				/* Disable all endpoints other than EP0 */
+				writel(readl(&chip->regs->control) & ~D_USB_CONF,
+				       &chip->regs->control);
+
+				usb_gadget_set_state(&chip->gadget, USB_STATE_ADDRESS);
+			} else {
+				/* Enable all endpoints */
+				writel(readl(&chip->regs->control) | D_USB_CONF,
+				       &chip->regs->control);
+
+				usb_gadget_set_state(&chip->gadget, USB_STATE_CONFIGURED);
+			}
+			ret = CX_IDLE;
+			break;
+
+		case USB_REQ_SET_ADDRESS:
+			TRACEEP(ep, "usbf: set_addr(0x%04X)\n", ctrl->wValue);
+			writel(value << 16, &chip->regs->address);
+			usb_gadget_set_state(&chip->gadget, USB_STATE_ADDRESS);
+			ret = CX_FINISH;
+			break;
+
+		case USB_REQ_CLEAR_FEATURE:
+			TRACEEP(ep, "usbf: clr_feature(%d, %d)\n",
+			      ctrl->bRequestType & 0x03, ctrl->wValue);
+			switch (ctrl->wValue) {
+			case 0:    /* [Endpoint] halt */
+				/* TODO ? */
+			/*	ep_reset(chip, ctrl->wIndex); */
+				TRACEEP(ep, "endpoint reset ?!?\n");
+				ret = CX_FINISH;
+				break;
+			case 1:    /* [Device] remote wake-up */
+			case 2:    /* [Device] test mode */
+			default:
+				ret = CX_STALL;
+				break;
+			}
+			break;
+
+		case USB_REQ_SET_FEATURE:
+			TRACEEP(ep, "usbf: set_feature(%d, %d)\n",
+			      ctrl->wValue, ctrl->wIndex & 0xf);
+			switch (ctrl->wValue) {
+			case 0:    /* Endpoint Halt */
+				ret = CX_FINISH;
+				/* TODO */
+			/*	id = ctrl->wIndex & 0xf; */
+				break;
+			case 1:    /* Remote Wakeup */
+			case 2:    /* Test Mode */
+			default:
+				ret = CX_STALL;
+				break;
+			}
+			break;
+		case USB_REQ_GET_STATUS:
+			TRACEEP(ep, "usbf: get_status(%d, %d, type %d)\n",
+			      ctrl->wValue, ctrl->wIndex,
+			      ctrl->bRequestType & USB_RECIP_MASK);
+			chip->setup[0] = 0;
+			switch (ctrl->bRequestType & USB_RECIP_MASK) {
+			case USB_RECIP_DEVICE:
+				chip->setup[0] = 1 << USB_DEVICE_SELF_POWERED;
+				break;
+			}
+			/* mark it as static, don't 'free' it */
+			chip->setup_reply.req.complete = NULL;
+			chip->setup_reply.req.buf = &chip->setup;
+			chip->setup_reply.req.length = 2;
+			usb_ep_queue(&ep->ep, &chip->setup_reply.req, 0);
+			ret = CX_FINISH;
+			break;
+		case USB_REQ_SET_DESCRIPTOR:
+			TRACEEP(ep, "usbf: set_descriptor\n");
+			break;
+		}
+	} /* if ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) */
+
+	if (!chip->driver) {
+		dev_warn(chip->dev, "Spurious SETUP");
+		ret = CX_STALL;
+	} else if (ret == CX_IDLE && chip->driver->setup) {
+		if (chip->driver->setup(&chip->gadget, ctrl) < 0)
+			ret = CX_STALL;
+		else
+			ret = CX_FINISH;
+	}
+
+	switch (ret) {
+	case CX_FINISH:
+		break;
+	case CX_STALL:
+		usbf_ep0_stall(ep_reg);
+		TRACEEP(ep, "usbf: cx_stall!\n");
+		break;
+	case CX_IDLE:
+		TRACEEP(ep, "usbf: cx_idle?\n");
+	default:
+		break;
+	}
+}
+
+static int usbf_req_is_control_no_data(struct usb_ctrlrequest *ctrl)
+{
+	return (ctrl->wLength == 0);
+}
+
+static int usbf_req_is_control_read(struct usb_ctrlrequest *ctrl)
+{
+	if (ctrl->wLength && (ctrl->bRequestType & USB_DIR_IN))
+		return 1;
+	return 0;
+}
+
+static int usbf_req_is_control_write(struct usb_ctrlrequest *ctrl)
+{
+	if (ctrl->wLength && !(ctrl->bRequestType & USB_DIR_IN))
+		return 1;
+	return 0;
+}
+
+static void usbf_ep0_interrupt(
+	struct f_endpoint *ep)
+{
+	struct f_regs_ep0 *ep_reg = &ep->chip->regs->ep0;
+	struct f_drv *chip = ep->chip;
+	struct usb_ctrlrequest *ctrl = (struct usb_ctrlrequest *)chip->setup;
+
+/*	TRACE("%s status %08x control %08x\n", __func__, ep->status,
+		readl(&ep_reg->control)); */
+
+	if (ep->status & D_EP0_OUT_INT) {
+		struct f_req *req;
+
+		spin_lock_irq(&ep->lock);
+		req = list_first_entry_or_null(&ep->queue, struct f_req, queue);
+		spin_unlock_irq(&ep->lock);
+
+		if (req)
+			usbf_ep0_out_isr(ep, req);
+	}
+
+	if (ep->status & D_EP0_SETUP_INT) {
+		chip->setup[0] = readl(&chip->regs->setup_data0);
+		chip->setup[1] = readl(&chip->regs->setup_data1);
+
+		TRACEEP(ep, "%s SETUP %08x %08x dir %s len:%d\n", __func__,
+		      chip->setup[0], chip->setup[1],
+		      (ctrl->bRequestType & USB_DIR_IN) ? "input" : "output",
+		      readl(&ep->chip->regs->ep0.length));
+
+		if (usbf_req_is_control_write(ctrl)) {
+			usbf_ep0_clear_onak(ep_reg);
+		}
+		if (usbf_req_is_control_read(ctrl)) {
+			usbf_ep0_flush_buffer(ep_reg, D_EP0_IN_EMPTY);
+			usbf_ep0_clear_inak(ep_reg);
+		}
+
+		usbf_ep0_setup(ep, ctrl);
+	}
+	if (ep->status & D_EP0_STG_START_INT) {
+		TRACEEP(ep, "%s START %08x %08x (empty: %s)\n", __func__,
+		      chip->setup[0], chip->setup[1],
+		      (ep->status & D_EP0_IN_EMPTY) ?
+				"IN empty" : "IN NOT empty");
+
+		if (usbf_req_is_control_read(ctrl)) {
+			usbf_ep0_clear_onak(ep_reg);
+		}
+		if (usbf_req_is_control_write(ctrl)) {
+			usbf_ep0_flush_buffer(ep_reg, D_EP0_OUT_EMPTY);
+			usbf_ep0_clear_inak(ep_reg);
+		}
+		if (usbf_req_is_control_no_data(ctrl)) {
+			usbf_ep0_flush_buffer(ep_reg, D_EP0_IN_EMPTY);
+			usbf_ep0_clear_inak(ep_reg);
+		}
+
+		/* TODO, we should send a NULL packet for Control-No-Data, but read a NULL packet for Control-Read */
+		usbf_ep0_send(ep, NULL);
+	}
+
+	ep->status = 0;
+}
+
+static const struct f_endpoint_drv usbf_ep0_callbacks = {
+	.enable = usbf_ep0_enable,
+	/* No DMA callbacks for endpoint 0 */
+	.recv[USBF_PROCESS_PIO] = usbf_ep0_recv,
+	.send[USBF_PROCESS_PIO] = usbf_ep0_send,
+	.interrupt = usbf_ep0_interrupt,
+	.reset = usbf_ep0_reset,
+};
+
+int usbf_ep0_init(struct f_endpoint *ep)
+{
+	struct f_regs_ep0 *ep_reg = &ep->chip->regs->ep0;
+
+	ep->drv = &usbf_ep0_callbacks;
+	ep->ep.maxpacket = CFG_EP0_MAX_PACKET_SIZE;
+	strcat(ep->name, "-control");
+
+	usbf_ep0_flush_buffer(ep_reg, D_EP0_OUT_EMPTY | D_EP0_IN_EMPTY);
+
+	return 0;
+}
diff --git a/drivers/usb/gadget/udc/usbf-renesas-epn.c b/drivers/usb/gadget/udc/usbf-renesas-epn.c
new file mode 100644
index 0000000..e5c6bc5
--- /dev/null
+++ b/drivers/usb/gadget/udc/usbf-renesas-epn.c
@@ -0,0 +1,449 @@
+/*
+ * Renesas RZ/N1 USB Device usb gadget driver
+ *
+ * Copyright 2015 Renesas Electronics Europe Ltd.
+ * Author: Michel Pollet <michel.pollet@bp.renesas.com>,<buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/iopoll.h>
+#include <linux/kernel.h>
+#include "usbf-renesas.h"
+
+/*
+ * TODO TODO TODO
+ *
+ * Currently, if the 'packet size' of the descriptor is used to configure
+ * the dma/sram for the endpoints, it works well for when the device starts at
+ * full speed. However, if the gadget starts at high speed, the memory allocated
+ * won't be enough if the link is then renegotiated  to full speed.
+ * We need a bit of heuristics at enable time to know if we ought to allocate
+ * more, or if we can use the descriptor values.
+ */
+/* Example of memory configuration with 5024 * 32 bits words
+ * 5024 * 32 bits = 20096 bytes of device memory
+	ep1-bulk	2 * 512		1024
+	ep2-bulk	2 * 512		1024
+	ep3-bulk	2 * 512		1024
+	ep4-bulk	2 * 512		1024
+	ep5-bulk	2 * 512		1024	   5120
+	ep6-int		2 * 64		128	- No DMA
+	ep7-int		2 * 64		128
+	ep8-int		2 * 64		128
+	ep9-int		2 * 64		128	+   512
+	ep10-iso	2 * 1024	2048
+	ep11-iso	2 * 1024	2048
+	ep12-iso	2 * 1024	2048
+	ep13-iso	2 * 1024	2048
+	ep14-iso	2 * 1024	2048
+	ep15-iso	2 * 1024	2048	+ 12288
+						= 17920
+ */
+static int usbf_epn_enable(
+	struct f_endpoint *ep)
+{
+	struct f_drv *chip = ep->chip;
+	struct f_regs_ep *ep_reg = ep->reg;
+	int in = usb_endpoint_dir_in(ep->desc);
+
+	/* Get the number of packets from EP config, CHIP config, or default */
+	if (!ep->max_nr_pkts)
+		ep->max_nr_pkts = chip->dma_pkt_count[ep->type];
+	if (!ep->max_nr_pkts)
+		ep->max_nr_pkts = 2;
+
+	TRACEEP(ep, "%s[%d] %s maxpackets %d/%d\n", __func__, ep->id,
+		in ? "IN" : "OUT", ep->ep.maxpacket, ep->ep.maxpacket_limit);
+
+	/* Set the internal IP base address, and increment the pointer with
+	 * the number of packets we plan to keep for that endpoint
+	 * Note: We do this even if this endpoint is 'no dma' as it will still
+	 * need some memory to function; this is the case for the interrupt
+	 * endpoints
+	 */
+	writel((ep->chip->dma_ram_used << 16) | usb_endpoint_maxp(ep->desc),
+		&ep_reg->pckt_adrs);
+	ep->chip->dma_ram_used +=
+		(ep->max_nr_pkts * usb_endpoint_maxp(ep->desc)) / 4;
+	/* Warn if we go overboard */
+	if (chip->dma_ram_size &&
+			ep->chip->dma_ram_used > chip->dma_ram_size) {
+		dev_warn(chip->dev, "EP[%d] SRAM overflow (%d/%d)!\n",
+			ep->id, chip->dma_ram_used, chip->dma_ram_size);
+	}
+	TRACE("%s[%d] packets %d*%d pckt_adrs %08x\n",
+		__func__, ep->id,
+		ep->max_nr_pkts, usb_endpoint_maxp(ep->desc),
+		readl(&ep_reg->pckt_adrs));
+
+	writel(in ?	0 :
+			D_EPN_OUT_EN | D_EPN_OUT_END_EN,
+		&ep_reg->int_enable);
+	/* Clear, set endpoint direction, and enable */
+	writel(D_EPN_EN | D_EPN_BCLR | (in ? 0 : D_EPN_DIR0), &ep_reg->control);
+	return 0;
+}
+
+static void usbf_epn_disable(
+	struct f_endpoint *ep)
+{
+	struct f_regs_ep *ep_reg = ep->reg;
+
+	TRACEEP(ep, "%s[%d]\n", __func__, ep->id);
+
+	/* Disable endpoint */
+	writel(readl(&ep_reg->control) & ~D_EPN_EN, &ep_reg->control);
+}
+
+static void usbf_epn_reset(
+	struct f_endpoint *ep)
+{
+	struct f_regs_ep *ep_reg = ep->reg;
+
+	writel(readl(&ep_reg->control) | D_EPN_BCLR, &ep_reg->control);
+}
+
+static int usbf_epn_send1(
+	struct f_endpoint *ep,
+	uint32_t *src,
+	int reqlen)
+{
+	struct f_regs_ep *ep_reg = ep->reg;
+	uint32_t control;
+	int w, len, err;
+	uint32_t val;
+	int pkt_words = reqlen / sizeof(*src);
+
+	/* Wait until there is space to write the pkt */
+	err = readl_poll_timeout(&ep_reg->status, val, (val & D_EPN_IN_EMPTY),
+			0, 10000);
+	if (err)
+		return -ETIMEDOUT;
+
+	/* Note, we don't care about endianness here, as the IP
+	 * and the core will have the same layout anyway, so we
+	 * can happily ignore it */
+	for (w = 0; w < pkt_words; w++)
+		writel(*src++, &ep_reg->write);
+
+	control = readl(&ep_reg->control);
+
+	/* if we have stray bytes, write them off too, and mark the
+	 * control registers so it knows only 1,2,3 bytes are valid in
+	 * the last write we made */
+	len = reqlen & (sizeof(*src) - 1);
+	if (len) {
+		writel(*src, &ep_reg->write);
+		control |= (len << 5);
+	}
+
+	writel(control | D_EPN_DEND, &ep_reg->control);
+
+	return 0;
+}
+
+static int usbf_epn_send(
+	struct f_endpoint *ep,
+	struct f_req *req)
+{
+	struct f_regs_ep *ep_reg = ep->reg;
+
+	/* Special handling for internally generated NULL packets */
+	if (!req) {
+		writel(readl(&ep_reg->control) | D_EPN_DEND, &ep_reg->control);
+		return 0;
+	}
+
+	if (req->req.length) {
+		void *src = req->req.buf;
+		int bytes = req->req.length;
+		int maxpkt_bytes = ep->ep.maxpacket;
+		int ret;
+
+		while (bytes > 0) {
+			int pkt_bytes = min(bytes, maxpkt_bytes);
+
+			ret = usbf_epn_send1(ep, src, pkt_bytes);
+			if (ret < 0) {
+				req->req.status = ret;
+				return ret;
+			}
+
+			bytes -= pkt_bytes;
+			src += pkt_bytes;
+		}
+		req->req.actual = req->req.length;
+		req->req.status = 0;
+	}
+
+	/* UDC asking for a ZLP to follow? */
+	if (req->req.length == 0 || req->req.zero)
+		req->req.status = usbf_epn_send1(ep, NULL, 0);
+
+	TRACERQ(req, "%s[%d][%3d] sent %d\n", __func__,
+		ep->id, req->seq, req->req.length);
+
+	return req->req.status;
+}
+
+static int usbf_epn_pio_recv(
+	struct f_endpoint *ep,
+	struct f_req *req,
+	uint32_t reqlen)
+{
+	struct f_regs_ep *ep_reg = ep->reg;
+
+	uint32_t *buf = req->req.buf + req->req.actual;
+	int len = (reqlen + sizeof(*buf) - 1) /  sizeof(*buf);
+
+	TRACERQ(req, "%s[%d][%3d] size %d (%d/%d)\n", __func__,
+		ep->id, req->seq, len,
+	      req->req.actual, req->req.length);
+
+	while (len-- > 0)
+		*buf++ = readl(&ep_reg->read);
+
+	req->req.actual += reqlen;
+
+	/* If we get a whole packet, we don't know if its the end of the
+	 * request yet. If it was everything, then we will get a null packet
+	 * as well.
+	 */
+	if (reqlen != usb_endpoint_maxp(ep->desc))
+		req->req.status = 0;
+
+	return req->req.status;
+}
+
+/* This is called from the tasklet to determine if we have received data.
+ * All of the processing is interrupt driven, so this function simply returns
+ * the status of the request.
+ */
+static int usbf_epn_recv(
+	struct f_endpoint *ep,
+	struct f_req *req)
+{
+	return req->req.status;
+}
+
+/*
+ * This setups a DMA transfer for both directions, to and from the device.
+ */
+static int usbf_epn_dma(
+	struct f_endpoint *ep,
+	struct f_req *req,
+	uint32_t size)
+{
+	struct f_regs_ep *ep_reg = ep->reg;
+	struct f_regs_epdma *dma = &ep->chip->regs->epdma[ep->id];
+	uint32_t max_size = usb_endpoint_maxp(ep->desc);
+	uint32_t pkt_count;
+	uint32_t last_size;
+	uint32_t control = 0;
+
+	/* Should not be necessary here, but lets be paranoid */
+	writel(D_EPN_STOP_MODE | D_EPN_STOP_SET | D_EPN_DMAMODE0, &ep_reg->dma_ctrl);
+
+	/* Ensure DMA is not trying to handle any odd bytes */
+	size &= ~3;
+
+	/* trim the size to max packets worth of stuff */
+	if (size > CFG_EPX_MAX_PACKET_CNT * max_size)
+		size = CFG_EPX_MAX_PACKET_CNT * max_size;
+
+	pkt_count = (size + max_size - 1) / max_size;
+	last_size = size % max_size;
+
+	/* keep it around for the usbf_epn_dma_complete() function sake */
+	req->dma_pkt_count = pkt_count - 1;
+
+	TRACERQ(req, "%s[%d][%3d] %d/%d size %d - pkt %d size %d last_size %d = %d\n",
+		__func__, ep->id, req->seq,
+		req->req.actual, req->req.length, size,
+		(pkt_count - 1), max_size, last_size,
+		((pkt_count - 1) * max_size) + last_size);
+
+	writel(pkt_count << 16, &ep_reg->len_dcnt);
+	/* set address, offset by what was already transferred */
+	writel(req->req.dma + req->req.actual, &dma->epntadr);
+	/* Packet size + last packet size */
+	writel((last_size << 16) | max_size, &dma->epndcr2);
+	/* Number of packet again, enable + direction flag */
+	/* Always needs to be > 0 here, if not in burst mode */
+	writel((((pkt_count ? pkt_count : 1) & 0xff) << 16) |
+		D_SYS_EPN_REQEN |
+		(req->to_host ? 0 : D_SYS_EPN_DIR0),
+		&dma->epndcr1);
+
+	/* Mark it so we don't try to restart a transfer */
+	req->req.status = -EBUSY;
+	control = D_EPN_DMA_EN | D_EPN_STOP_MODE | D_EPN_STOP_SET | D_EPN_DMAMODE0;
+	if (pkt_count > 1 && last_size == 0)
+		control |= D_EPN_BURST_SET;
+	/* If we are sending, and are either sending a full packet or sending
+	 * the exact remaining of the request using the DMA (no unaligned
+	 * length) then we set the DEND flag so the DMA end will also send the
+	 * packet.
+	 */
+	if (req->to_host) {
+		if (last_size == max_size ||
+			req->req.actual + size == req->req.length)
+				control |= D_EPN_DEND_SET;
+	}
+	/* Start it... */
+	writel(control, &ep_reg->dma_ctrl);
+
+	return -EBUSY;
+}
+
+/* Handle DMA rx complete (OUT_END) interrupt */
+static void usbf_epn_out_end_isr(
+	struct f_endpoint *ep,
+	struct f_req *req)
+{
+	struct f_regs_ep *ep_reg = ep->reg;
+	struct f_regs_epdma *dma = &ep->chip->regs->epdma[ep->id];
+
+	uint32_t reqlen = readl(&ep_reg->len_dcnt) & D_EPN_LDATA;
+	/* number of packets has been decremented from the dma_pkt_count */
+	uint32_t pkts_left = (readl(&dma->epndcr1) >> 16) & 0xff;
+	uint32_t pkts_got = 0;
+
+	/* Clear REQEN, i.e. disable DMA */
+	writel((req->to_host ? 0 : D_SYS_EPN_DIR0), &dma->epndcr1);
+
+	/* The number of packets received is the difference between what we
+	 * asked for and the uncompleted packets. */
+	if (req->dma_pkt_count)
+		pkts_got = req->dma_pkt_count - pkts_left + 1;
+
+	/* Update amount transferred */
+	/* The burst and non-burst method have the same behaviour
+	 * regarding the calculation of what has been transferred */
+	req->req.actual += pkts_got * usb_endpoint_maxp(ep->desc);
+	req->req.actual += req->dma_non_burst_bytes;
+
+	TRACERQ(req, "%s[%d][%3d] reqlen %d pkts_sent %d actual %d/%d\n",
+		__func__, ep->id, req->seq,
+		reqlen, pkts_got,
+		req->req.actual, req->req.length);
+
+	/* DMA it! */
+	if (reqlen >= 4) {
+		usbf_epn_dma(ep, req, reqlen);
+		req->dma_non_burst_bytes = reqlen & ~3;
+		return;
+	}
+
+	usbf_epn_pio_recv(ep, req, reqlen);
+}
+
+/* Handle rx data received (OUT) interrupt */
+/* The hardware has captured a USB packet in it's internal RAM and we need to
+ * use PIO or start DMA to move it out. The OUT_END interrupt tells us when the
+ * DMA of one USB packet has finished, and so is used to start subsequent DMA
+ * transfers for this request. */
+static void usbf_epn_out_isr(
+	struct f_endpoint *ep,
+	struct f_req *req)
+{
+	struct f_drv *chip = ep->chip;
+	struct f_regs_ep *ep_reg = ep->reg;
+	struct f_regs_epdma *dma = &ep->chip->regs->epdma[ep->id];
+
+	uint32_t reqlen = readl(&ep_reg->len_dcnt) & D_EPN_LDATA;
+
+	/* if a DMA is in progress, ignore this interrupt */
+	if (readl(&dma->epndcr1) & D_SYS_EPN_REQEN)
+		return;
+
+	/* If it's not a short packet, we want to do a burst DMA so
+	 * increase the request length to the max we want.
+	 * Otherwise, a short packet tells us the total we will get */
+	if (reqlen == usb_endpoint_maxp(ep->desc)) {
+		reqlen = req->req.length - req->req.actual;
+		req->dma_non_burst_bytes = 0;
+	} else
+		req->dma_non_burst_bytes = reqlen & ~3;
+
+	TRACERQ(req, "%s[%d][%3d] reqlen %d actual %d/%d\n",
+		__func__, ep->id, req->seq,
+		reqlen, req->req.actual, req->req.length);
+
+	/* DMA it! */
+	if (req->use_dma && reqlen >= chip->dma_threshold) {
+		usbf_epn_dma(ep, req, reqlen);
+		return;
+	}
+
+	/* If using PIO, we only recieve one USB packet at a time */
+	if (reqlen > usb_endpoint_maxp(ep->desc))
+		reqlen = usb_endpoint_maxp(ep->desc);
+
+	usbf_epn_pio_recv(ep, req, reqlen);
+}
+
+static void usbf_epn_interrupt(struct f_endpoint *ep)
+{
+	struct f_req *req;
+
+	spin_lock_irq(&ep->lock);
+	req = list_first_entry_or_null(&ep->queue, struct f_req, queue);
+	spin_unlock_irq(&ep->lock);
+
+	/* Ensure we have a request, and that we have work to do on it */
+	if (!req || req->req.status == 0)
+		return;
+
+	/* Note: D_EPN_OUT_INT must be before D_EPN_OUT_END_INT.
+	 * Since we get OUT interrupts during DMA, we can pick up both OUT and
+	 * OUT_END interrupt at the same time. If we handle the OUT_END first
+	 * (and disable DMA), the OUT will look like a spurious interrupt.
+	 * By calling usbf_ep_process_queue() here, we make this EP return data
+	 * to other parts of the kernel quicker. This seems to be important...
+	 */
+	if (ep->status & D_EPN_OUT_END_INT) {
+		ep->status &= ~D_EPN_OUT_END_INT;
+		usbf_epn_out_end_isr(ep, req);
+	} else if (ep->status & D_EPN_OUT_INT) {
+		ep->status &= ~D_EPN_OUT_INT;
+		usbf_epn_out_isr(ep, req);
+	} else if (ep->status & D_EPN_IN_INT) {
+		/* EPN_IN_INT means we have finished tx so we just want to poke the
+		 * queue to ensure any pending requests are processed */
+		ep->status &= ~D_EPN_IN_INT;
+	}
+
+	usbf_ep_process_queue(ep);
+}
+
+static const struct f_endpoint_drv usbf_epn_callbacks = {
+	.enable = usbf_epn_enable,
+	.disable = usbf_epn_disable,
+	/* .set_maxpacket = usbf_epn_set_maxpacket, */
+	.recv[USBF_PROCESS_PIO] = usbf_epn_recv,
+	.send[USBF_PROCESS_PIO] = usbf_epn_send,
+	.recv[USBF_PROCESS_DMA] = usbf_epn_recv,
+	.interrupt = usbf_epn_interrupt,
+	.reset = usbf_epn_reset,
+};
+
+int usbf_epn_init(struct f_endpoint *ep)
+{
+	struct f_regs_ep *ep_reg = &ep->chip->regs->ep[ep->id - 1];
+	static const char * const et[] = {
+		[USBF_EP_BULK] = "-bulk",
+		[USBF_EP_INT] = "-int",
+		[USBF_EP_ISO] = "-iso"
+	};
+
+	ep->reg = ep_reg;
+	ep->type = (readl(&ep_reg->control) >> 24) & 3;
+	ep->drv = &usbf_epn_callbacks;
+	strcat(ep->name, et[ep->type]);
+
+	return 0;
+}
diff --git a/drivers/usb/gadget/udc/usbf-renesas.c b/drivers/usb/gadget/udc/usbf-renesas.c
new file mode 100644
index 0000000..c1b76cc
--- /dev/null
+++ b/drivers/usb/gadget/udc/usbf-renesas.c
@@ -0,0 +1,1114 @@
+/*
+ * Renesas RZ/N1 USB Device usb gadget driver
+ *
+ * Copyright 2015 Renesas Electronics Europe Ltd.
+ * Author: Michel Pollet <michel.pollet@bp.renesas.com>,<buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/sysctrl-rzn1.h>
+
+#include "usbf-renesas.h"
+
+#ifdef	CONFIG_DEBUG_FS
+#include <linux/debugfs.h>
+#endif
+
+#define DRIVER_DESC     "Renesas USB Function driver"
+#define DRIVER_AUTHOR   "Michel Pollet"
+#define DRIVER_VERSION  "0.2"
+
+#define DMA_ADDR_INVALID        (~(dma_addr_t)0)
+
+static const char driver_name[] = "usbf_renesas";
+static const char driver_desc[] = DRIVER_DESC;
+
+#ifdef	CONFIG_DEBUG_FS
+struct f_drv *usbf;
+#endif
+
+static struct usb_endpoint_descriptor ep0_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = USB_DT_ENDPOINT,
+	.bEndpointAddress = USB_DIR_IN,
+	.bmAttributes = USB_ENDPOINT_XFER_CONTROL,
+	.wMaxPacketSize = CFG_EP0_MAX_PACKET_SIZE,
+};
+
+/*
+ * activate/deactivate link with host.
+ */
+static void pullup(struct f_drv *chip, int is_on)
+{
+	struct f_regs *regs = chip->regs;
+
+	if (is_on) {
+		if (!chip->pullup) {
+			chip->pullup = 1;
+			writel((readl(&regs->control) & ~D_USB_CONNECTB) |
+				D_USB_PUE2, &regs->control);
+			usb_gadget_set_state(&chip->gadget, USB_STATE_POWERED);
+		}
+	} else {
+		chip->pullup = 0;
+		writel((readl(&regs->control) & ~D_USB_PUE2) |
+			D_USB_CONNECTB, &regs->control);
+		usb_gadget_set_state(&chip->gadget, USB_STATE_NOTATTACHED);
+	}
+}
+
+/*
+ * USB Gadget Layer
+ */
+static int usbf_ep_enable(
+	struct usb_ep *_ep,
+	const struct usb_endpoint_descriptor *desc)
+{
+	struct f_endpoint *ep = container_of(_ep, struct f_endpoint, ep);
+	struct f_drv *chip = ep->chip;
+	struct f_regs *regs = chip->regs;
+	unsigned long flags;
+
+	TRACE("%s[%d] desctype %d max pktsize %d\n", __func__, ep->id,
+	      desc->bDescriptorType,
+	      usb_endpoint_maxp(desc));
+	if (!_ep || !desc || desc->bDescriptorType != USB_DT_ENDPOINT) {
+		TRACE("%s: bad ep or descriptor\n", __func__);
+		return -EINVAL;
+	}
+
+	/* it might appear as we nuke the const here, but in this case,
+	 * we just need the ep0 to be able to change the endpoint direction,
+	 * and we know it does that on a non-const copy of its descriptor,
+	 * while the other endpoints don't touch it anyway */
+	ep->desc = (struct usb_endpoint_descriptor *)desc;
+	ep->ep.maxpacket = usb_endpoint_maxp(desc);
+
+	if (ep->drv->enable)
+		ep->drv->enable(ep);
+	if (ep->drv->set_maxpacket)
+		ep->drv->set_maxpacket(ep);
+	ep->disabled = 0;
+
+	/* enable interrupts for this endpoint */
+	spin_lock_irqsave(&chip->lock, flags);
+	writel(readl(&regs->int_enable) | (D_USB_EP0_EN << ep->id),
+	       &regs->int_enable);
+	spin_unlock_irqrestore(&chip->lock, flags);
+
+	return 0;
+}
+
+static int usbf_ep_disable(struct usb_ep *_ep)
+{
+	struct f_endpoint *ep = container_of(_ep, struct f_endpoint, ep);
+	struct f_drv *chip = ep->chip;
+	struct f_regs *regs = chip->regs;
+	unsigned long flags;
+
+	TRACE("%s(%d)\n", __func__, ep->id);
+
+	/* disable interrupts for this endpoint */
+	spin_lock_irqsave(&chip->lock, flags);
+	writel(readl(&regs->int_enable) & ~(D_USB_EP0_EN << ep->id),
+	       &regs->int_enable);
+	spin_unlock_irqrestore(&chip->lock, flags);
+	if (ep->drv->disable)
+		ep->drv->disable(ep);
+	ep->desc = NULL;
+	ep->disabled = 1;
+	return 0;
+}
+
+static struct usb_request *usbf_ep_alloc_request(
+	struct usb_ep *_ep, gfp_t gfp_flags)
+{
+	struct f_req *req = kzalloc(sizeof(*req), gfp_flags);
+
+	if (!req)
+		return NULL;
+
+	req->req.dma = DMA_ADDR_INVALID;
+	INIT_LIST_HEAD(&req->queue);
+
+	return &req->req;
+}
+
+static void usbf_ep_free_request(
+	struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct f_req *req = container_of(_req, struct f_req, req);
+	struct f_endpoint *ep = container_of(_ep, struct f_endpoint, ep);
+
+	spin_lock_irq(&ep->lock);
+	list_del_init(&req->queue);
+	spin_unlock_irq(&ep->lock);
+	kfree(req);
+}
+
+static int usbf_ep_queue(
+	struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
+{
+	struct f_endpoint *ep = container_of(_ep, struct f_endpoint, ep);
+	struct f_drv *chip = ep->chip;
+	struct f_req *req = container_of(_req, struct f_req, req);
+	int was_empty = list_empty(&ep->queue);
+
+	if (!_req || !_req->buf) {
+		TRACE("%s: invalid request to ep%d\n", __func__, ep->id);
+		return -EINVAL;
+	}
+
+	if (!chip || chip->state == USB_STATE_SUSPENDED) {
+		TRACE("%s: request while chip suspended\n", __func__);
+		return -EINVAL;
+	}
+	req->trace = 0;
+	req->req.actual = 0;
+	req->req.status = -EINPROGRESS;
+	req->seq = ep->seq++; /* debug */
+	req->to_host = usb_endpoint_dir_in(ep->desc);
+	/* Basic criteria for using DMA on this request */
+	req->use_dma = ep->has_dma && ep->id != 0 &&
+			req->req.length > chip->dma_threshold;
+
+	/* DISABLE DMA */
+	req->use_dma = 0;
+
+	/* This technically is a kludge, we test the pointer /before/ we
+	 * bother to DMA map it and 'discover' it's also been mapped to an
+	 * unaligned address. In testing, the lower part of the pointers
+	 * stay the same anyway, so testing before we map is valid. */
+	if (req->use_dma && ((u32)req->req.buf & 3)) {
+		req->use_dma = 0;
+		TRACEEP(ep, "%s[%d][%3d] WARNING unaligned buffer at %p -- DMA Disabled\n",
+			__func__, ep->id, req->seq, req->req.buf);
+	}
+
+	/* The endpoint driver has 2 types of transfer callbacks, one for
+	 * receiving and one for sending; we know at 'queue' time the direction
+	 * the endpoint is, so we can install the correct one with the request
+	 * and let it do the job until completion */
+
+	/* if DMA callback is not present, fallback to PIO */
+	if (req->to_host) {
+		if (req->use_dma && !ep->drv->send[USBF_PROCESS_DMA])
+			req->use_dma = 0;
+		req->process = ep->drv->send[req->use_dma];
+	} else {
+		if (req->use_dma && !ep->drv->recv[USBF_PROCESS_DMA])
+			req->use_dma = 0;
+		req->process = ep->drv->recv[req->use_dma];
+	}
+	/* Prepare the buffer for DMA, if necessary */
+	if (req->use_dma) {
+		if (req->req.dma == DMA_ADDR_INVALID) {
+			if (usb_gadget_map_request(&chip->gadget, &req->req,
+						req->to_host)) {
+				pr_err("dma_mapping_error\n");
+				req->req.dma = DMA_ADDR_INVALID;
+				req->use_dma = 0;
+			} else
+				req->mapped = 1;
+		}
+	}
+
+	TRACEEP(ep, "%s[%d][%3d], dma:%d mapped:%d len %3d %s %s\n", __func__,
+		ep->id, req->seq, req->use_dma, req->mapped,
+		req->req.length,
+		req->to_host ? "input" : "output",
+		req->req.zero ? "ZERO" : "(no zero)");
+	if (req->use_dma) /* DMA is still possible */
+		dma_sync_single_for_device(
+			chip->dev,
+			req->req.dma, req->req.length,
+			req->to_host ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+	/* This is /required/ -- you cannot queue these requests, because
+	 * the upper layer doesn't assume they will be queued and will call
+	 * queue() again with the same request, polluting the list; so we
+	 * need to complete() it now, even tho it might actually be out of
+	 * sequence (if a packet is already in the queue */
+	if (req->req.length == 0) {
+		req->req.status = 0;
+		usb_gadget_giveback_request(&ep->ep, &req->req);
+		return 0;
+	}
+
+	spin_lock_irq(&ep->lock);
+	list_add_tail(&req->queue, &ep->queue);
+	spin_unlock_irq(&ep->lock);
+
+	/* kick a soft interrupt, in case we are not called from the tasklet */
+	if (req->to_host || was_empty)
+		tasklet_schedule(&chip->tasklet);
+
+	return 0;
+}
+
+static int usbf_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct f_endpoint *ep = container_of(_ep, struct f_endpoint, ep);
+	struct f_req *req = container_of(_req, struct f_req, req);
+	struct f_drv *chip = ep->chip;
+
+	/* dequeue the request */
+	spin_lock_irq(&ep->lock);
+	list_del_init(&req->queue);
+	spin_unlock_irq(&ep->lock);
+
+	if (req->use_dma) {
+		req->use_dma = 0;
+		dma_sync_single_for_cpu(
+			chip->dev,
+			req->req.dma, req->req.length,
+			req->to_host ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+	}
+	TRACEEP(ep, "%s[%d][%3d] size %d\n", __func__,
+			ep->id, req->seq, req->req.actual);
+
+	if (req->trace ||
+		(ep->trace_min && req->req.actual >= ep->trace_min &&
+		(ep->trace_max == 0 || req->req.actual <= ep->trace_max))) {
+		req->trace = 1;
+		TRACERQ(req, "%s[%d][%3d] DUMP %d buf:%p dma %08x:\n",
+			__func__, ep->id, req->seq, req->req.actual,
+			req->req.buf, req->req.dma);
+	//	print_hex_dump_bytes("pkt", DUMP_PREFIX_OFFSET,
+	//		req->req.buf, req->req.actual);
+	}
+	if (req->mapped) {
+		usb_gadget_unmap_request(&chip->gadget, &req->req,
+				req->to_host);
+		/* ^^ doesn't do this:  */
+		req->req.dma = DMA_ADDR_INVALID;
+		req->mapped = 0;
+	}
+
+	/* don't modify queue heads during completion callback */
+	if (chip->gadget.speed == USB_SPEED_UNKNOWN)
+		req->req.status = -ESHUTDOWN;
+
+	if (req->req.complete)
+		usb_gadget_giveback_request(&ep->ep, &req->req);
+
+	return 0;
+}
+
+/*
+ * This function is called repeatedly on each endpoint. Its job is to
+ * 'process' the current queued request (top of the queue) and 'complete'
+ * it when it's finished.
+ */
+int usbf_ep_process_queue(struct f_endpoint *ep)
+{
+	struct f_req *req;
+
+	spin_lock_irq(&ep->lock);
+	req = list_first_entry_or_null(&ep->queue, struct f_req, queue);
+	spin_unlock_irq(&ep->lock);
+
+	if (req && req->process(ep, req) == 0) {
+		/* 'complete' this request */
+		usbf_ep_dequeue(&ep->ep, &req->req);
+
+		/* If there are further requests, reschedule the tasklet */
+		spin_lock_irq(&ep->lock);
+		req = list_first_entry_or_null(&ep->queue, struct f_req, queue);
+		spin_unlock_irq(&ep->lock);
+		if (req)
+			return 1;
+	}
+
+	return 0;
+}
+
+static int usbf_ep_halt(struct usb_ep *_ep, int halt)
+{
+	struct f_endpoint *ep = container_of(_ep, struct f_endpoint, ep);
+	int ret = 0;
+
+	TRACEEP(ep, "%s[%d] halt=%d\n", __func__, ep->id, halt);
+	if (ep->drv->halt)
+		ret = ep->drv->halt(ep, halt);
+	return ret;
+}
+
+static void usbf_ep_reset(
+	struct f_endpoint *ep)
+{
+	TRACEEP(ep, "%s[%d] reset\n", __func__, ep->id);
+	if (ep->drv->reset)
+		ep->drv->reset(ep);
+	ep->status = 0;
+	/* flush anything that was pending */
+	while (!list_empty(&ep->queue)) {
+		struct f_req *req = list_first_entry(&ep->queue,
+					struct f_req, queue);
+		TRACEEP(ep, "%s[%d][%3d] dequeueing\n", __func__,
+			ep->id, req->seq);
+		req->req.status = -ECONNRESET;
+		usbf_ep_dequeue(&ep->ep, &req->req);
+	}
+}
+
+static struct usb_ep_ops usbf_ep_ops = {
+	.enable         = usbf_ep_enable,
+	.disable        = usbf_ep_disable,
+	.queue          = usbf_ep_queue,
+	.dequeue        = usbf_ep_dequeue,
+	.set_halt       = usbf_ep_halt,
+	.alloc_request  = usbf_ep_alloc_request,
+	.free_request   = usbf_ep_free_request,
+};
+
+/* If there's stuff in the fifo, collect it */
+static uint32_t usbf_tasklet_flush_fifo(
+	struct f_drv *chip)
+{
+	struct f_status s;
+	int i;
+	uint32_t int_status = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&chip->lock, flags);
+
+	/* If multiple sets of interrupt status bits have been pushed onto the
+	 * FIFO, or them together to get a complete set.
+	 */
+	if (kfifo_get(&chip->fifo, &s)) {
+		/* Mask out the global EP interrupt bits */
+		int_status = s.int_status & 0xf;
+		for (i = 0; i < CFG_NUM_ENDPOINTS; i++) {
+			chip->ep[i].status = s.ep[i];
+			/* Fake the global EP interrupt bits based on what we read */
+			if (s.ep[i])
+				int_status |= (D_USB_EP0_INT << i);
+		}
+	}
+
+	spin_unlock_irqrestore(&chip->lock, flags);
+
+	return int_status;
+}
+
+static void usbf_tasklet_process_irq(struct f_drv *chip, uint32_t int_status)
+{
+	int i;
+
+	if (int_status & D_USB_USB_RST_INT) {
+		if (chip->gadget.speed != USB_SPEED_UNKNOWN) {
+			TRACE("%s disconnecting\n", __func__);
+			chip->gadget.speed = USB_SPEED_UNKNOWN;
+			/* We assume all endpoints will be closed,
+			 * so reset the DMA memory pointer for later use */
+			chip->dma_ram_used = EP0_RAM_USED;
+			if (chip->driver)
+				chip->driver->disconnect(&chip->gadget);
+			else
+				dev_warn(chip->dev, "Spurious RST\n");
+		}
+	}
+	if (int_status & D_USB_SPEED_MODE_INT) {
+		if (readl(&chip->regs->status) & D_USB_SPEED_MODE)
+			chip->gadget.speed = USB_SPEED_HIGH;
+		else
+			chip->gadget.speed = USB_SPEED_FULL;
+		TRACE("**** %s speed change: %s\n", __func__,
+			chip->gadget.speed == USB_SPEED_HIGH ? "High" : "Full");
+	}
+#if 0
+	if (int_status & D_USB_SPND_INT)
+		TRACE("%s suspend clear\n", __func__);
+	if (int_status & D_USB_RSUM_INT)
+		TRACE("%s resume\n", __func__);
+#endif
+	for (i = 0; i < CFG_NUM_ENDPOINTS; i++) {
+		struct f_endpoint *ep = &chip->ep[i];
+
+		if (ep->disabled)
+			continue;
+
+		if (int_status & D_USB_USB_RST_INT)
+			usbf_ep_reset(ep);
+		/* speed change notification for endpoints */
+		if ((int_status & D_USB_SPEED_MODE_INT) &&
+				ep->drv->set_maxpacket)
+			ep->drv->set_maxpacket(ep);
+
+		/* Interrupt notification */
+		if ((int_status & (D_USB_EP0_INT << i)) && ep->drv->interrupt)
+			ep->drv->interrupt(ep);
+	}
+}
+
+static void usbf_tasklet(unsigned long data)
+{
+	struct f_drv *chip = (struct f_drv *)data;
+	uint32_t int_status;
+	int i, busy = 1;
+
+	while ((int_status = usbf_tasklet_flush_fifo(chip)) != 0)
+		usbf_tasklet_process_irq(chip, int_status);
+
+	while (busy) {
+		busy = 0;
+
+		for (i = 0; i < CFG_NUM_ENDPOINTS; i++) {
+			struct f_endpoint *ep = &chip->ep[i];
+
+			if (!ep->disabled)
+				busy |= usbf_ep_process_queue(ep);
+		}
+	}
+}
+
+static void usbf_attach(struct f_drv *chip)
+{
+	struct f_regs *regs = chip->regs;
+	uint32_t ctrl = readl(&regs->control);
+
+	/* Enable USB signal to Function PHY */
+	ctrl &= ~D_USB_CONNECTB;
+	/* D+ signal Pull-up */
+	ctrl |=  D_USB_PUE2;
+	/* Enable endpoint 0 */
+	ctrl |=  D_USB_DEFAULT;
+
+	writel(ctrl, &regs->control);
+}
+
+static void usbf_detach(struct f_drv *chip)
+{
+	struct f_regs *regs = chip->regs;
+	uint32_t ctrl = readl(&regs->control);
+
+	/* Disable USB signal to Function PHY */
+	ctrl |=  D_USB_CONNECTB;
+	/* Do not Pull-up D+ signal */
+	ctrl &= ~D_USB_PUE2;
+	/* Disable endpoint 0 */
+	ctrl &= ~D_USB_DEFAULT;
+	/* Disable the other endpoints */
+	ctrl &= ~D_USB_CONF;
+
+	writel(ctrl, &regs->control);
+
+	writel(0, &regs->ep0.status);
+}
+
+static irqreturn_t usbf_irq(int irq, void *_chip)
+{
+	struct f_drv *chip = (struct f_drv *)_chip;
+	struct f_regs *regs = chip->regs;
+	uint32_t sysbint = readl(&regs->sysbint);
+
+	/* clear interrupts */
+	writel(sysbint, &regs->sysbint);
+	if ((sysbint & D_SYS_VBUS_INT) == D_SYS_VBUS_INT) {
+		/* Interrupt factor clear */
+		if (readl(&regs->epctr) & D_SYS_VBUS_LEVEL) {
+			TRACE("%s plugged in\n", __func__);
+			usbf_attach(chip);
+			usb_gadget_set_state(&chip->gadget, USB_STATE_POWERED);
+		} else {
+			TRACE("%s plugged out\n", __func__);
+			usbf_detach(chip);
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Offload the IRQ flags into the FIFO ASAP, then return.
+ *
+ * The status flags are passed down to tasklet via a FIFO
+ */
+static irqreturn_t usbf_epc_irq(int irq, void *_chip)
+{
+	struct f_drv *chip = (struct f_drv *)_chip;
+	struct f_regs *regs = chip->regs;
+	struct f_status s;
+	int i;
+	u32 int_en;
+	unsigned long flags;
+
+	spin_lock_irqsave(&chip->lock, flags);
+
+	/* Disable interrupts */
+	int_en = readl(&regs->int_enable);
+	writel(0, &regs->int_enable);
+
+	/*
+	 * WARNING: Don't use the EP interrupt bits from this status reg as they
+	 * won't be coherent with the EP status registers.
+	 */
+	s.int_status = readl(&regs->int_status) & int_en;
+	writel(~s.int_status, &regs->int_status);
+
+	s.ep[0] = readl(&regs->ep0.status) & readl(&regs->ep0.int_enable);
+	writel(~s.ep[0], &regs->ep0.status);
+
+	for (i = 1; i < CFG_NUM_ENDPOINTS; i++) {
+		s.ep[i] = readl(&regs->ep[i - 1].status) & readl(&regs->ep[i - 1].int_enable);
+		writel(~s.ep[i], &regs->ep[i - 1].status);
+	}
+
+	if (!kfifo_put(&chip->fifo, s))
+		dev_err(chip->dev, "intstatus fifo full!\n");
+
+	/* Enable interrupts */
+	writel(int_en, &regs->int_enable);
+
+	spin_unlock_irqrestore(&chip->lock, flags);
+
+	tasklet_schedule(&chip->tasklet);
+
+	return IRQ_HANDLED;
+}
+
+/*-------------------------------------------------------------------------
+	Gadget driver probe and unregister.
+ --------------------------------------------------------------------------*/
+static int usbf_gadget_start(struct usb_gadget *gadget,
+		struct usb_gadget_driver *driver)
+{
+	struct f_drv *chip = container_of(gadget, struct f_drv, gadget);
+	struct device_node *np = chip->dev->of_node;
+
+	driver->driver.bus = NULL;
+	/* hook up the driver */
+	chip->driver = driver;
+	chip->gadget.speed = driver->max_speed;
+
+	dev_info(chip->dev, "%s bind to driver %s\n", chip->gadget.name,
+			driver->driver.name);
+	/* Finish initialization by getting possible overrides from DT */
+	if (np) {
+		int rm_len, i, pi;
+		const char * const names[] = {
+			[0] = kasprintf(GFP_KERNEL, "renesas,sram-conf,%s",
+				driver->driver.name),
+			[1] = "renesas,sram-conf",
+		};
+
+		/* reset all packet counts to default (2) */
+		for (pi = 0; pi < ARRAY_SIZE(names); pi++)
+			chip->ep[pi].max_nr_pkts = 0;
+		for (pi = 0; pi < ARRAY_SIZE(chip->dma_pkt_count); pi++)
+			chip->dma_pkt_count[pi] = 0;
+
+		for (pi = 0; pi < ARRAY_SIZE(names); pi++) {
+			const __be32 *conf = of_get_property(np,
+							names[pi], &rm_len);
+			TRACE("%s %s: %s : %p\n", __func__, driver->function,
+				names[pi], conf);
+			if (!conf)
+				continue;
+			rm_len /= sizeof(conf[0]);
+			if (rm_len > 3) { /* per-endpoint config */
+				for (i = 0; i < rm_len &&
+						i < ARRAY_SIZE(chip->ep); i++)
+					if (!chip->ep[i].max_nr_pkts)
+						chip->ep[i].max_nr_pkts =
+							be32_to_cpu(conf[i]);
+			} else { /* per endpoint type config */
+				for (i = 0; i < rm_len; i++)
+					if (!chip->dma_pkt_count[i])
+						chip->dma_pkt_count[i] =
+							be32_to_cpu(conf[i]);
+			}
+		}
+		kfree(names[0]);
+	}
+
+	return 0;
+}
+
+static int usbf_gadget_stop(struct usb_gadget *gadget)
+{
+	struct f_drv *chip = container_of(gadget, struct f_drv, gadget);
+
+	chip->gadget.speed = USB_SPEED_UNKNOWN;
+
+	dev_info(chip->dev, "unregistered gadget driver '%s'\n",
+			chip->driver->driver.name);
+	chip->driver = NULL;
+	return 0;
+}
+
+static int usbf_gadget_pullup(struct usb_gadget *_gadget, int is_on)
+{
+	struct f_drv *chip = container_of(_gadget, struct f_drv, gadget);
+
+	TRACE("%s: pullup=%d\n", __func__, is_on);
+
+	pullup(chip, is_on);
+
+	return 0;
+}
+
+static struct usb_gadget_ops usbf_gadget_ops = {
+	.pullup = usbf_gadget_pullup,
+	.udc_start = usbf_gadget_start,
+	.udc_stop = usbf_gadget_stop,
+};
+
+/*-----------------------------------------------------------------------
+ *	UDC device Driver operation functions				*
+ *----------------------------------------------------------------------*/
+static void usbf_release(struct device *dev)
+{
+	struct f_drv *chip = container_of(dev, struct f_drv, gadget.dev);
+
+	TRACE("%s\n", __func__);
+	complete(chip->done);
+
+	kfree(chip);
+}
+
+static int usbf_probe(struct platform_device *ofdev)
+{
+	int ret = -ENOMEM, i;
+	struct f_drv *chip;
+	struct device_node *np = ofdev->dev.of_node;
+
+	if (rzn1_sysctrl_readl(RZN1_SYSCTRL_REG_CFG_USB) &
+			(1 << RZN1_SYSCTRL_REG_CFG_USB_H2MODE)) {
+		dev_warn(&ofdev->dev, "disabled in H2 (host) mode\n");
+		return -1;
+	}
+
+	chip = devm_kzalloc(&ofdev->dev, sizeof(*chip), GFP_KERNEL);
+	if (chip == NULL)
+		return -ENOMEM;
+	chip->dev = &ofdev->dev;
+
+	chip->clk_fw = devm_clk_get(chip->dev, "axi");
+	if (IS_ERR(chip->clk_fw)) {
+		ret = PTR_ERR(chip->clk_fw);
+		goto clk_failed;
+	}
+	ret = clk_prepare_enable(chip->clk_fw);
+	if (ret) {
+		dev_err(chip->dev, "can not enable the clock\n");
+		goto clk_failed;
+	}
+
+	chip->regs = of_iomap(np, 0);
+	if (!chip->regs) {
+		dev_err(chip->dev, "unable to get register bank\n");
+		goto invalid_mapping;
+	}
+	if (!(readl(&chip->regs->usbssconf) & (1 << 16))) {
+		dev_err(chip->dev, "Invalid USBF configuration, bailing\n");
+		goto invalid_config;
+	}
+	chip->dma_threshold = 64;
+	chip->dma_ram_size = 5024;
+
+	chip->dma_ram_used = EP0_RAM_USED; /* after endpoint zero memory */
+
+	TRACE("%s USB Conf: %08x\n", __func__, readl(&chip->regs->usbssconf));
+
+	/* Resetting the PLL is handled via the clock driver as it has common
+	 * registers with USB Host */
+
+	spin_lock_init(&chip->lock);
+
+	/* modify in register gadget process */
+	chip->gadget.speed = USB_SPEED_FULL;
+	chip->gadget.max_speed = USB_SPEED_HIGH;
+	chip->gadget.ops = &usbf_gadget_ops;
+
+	/* name: Identifies the controller hardware type. */
+	chip->gadget.name = driver_name;
+	chip->gadget.dev.parent = &ofdev->dev;
+	/* gadget.ep0 is a pointer */
+	chip->gadget.ep0 = &chip->ep[0].ep;
+
+	INIT_LIST_HEAD(&chip->gadget.ep_list);
+	/* we have a canned request structure to allow sending packets
+	 * as reply to get_status requests */
+	INIT_LIST_HEAD(&chip->setup_reply.queue);
+
+	for (i = 0; i < CFG_NUM_ENDPOINTS; ++i) {
+		struct f_endpoint init = {
+			.ep = {
+				.ops = &usbf_ep_ops,
+				.maxpacket = CFG_EPX_MAX_PACKET_SIZE,
+			},
+			.id = i,
+			.disabled = 1,
+			.chip = chip,
+		};
+		struct f_endpoint *ep = chip->ep + i;
+
+		if (!(readl(&chip->regs->usbssconf) & (1 << (16 + i)))) {
+			TRACE("%s endpoint %d is not available\n", __func__, i);
+			continue;
+		}
+		*ep = init;
+		sprintf(ep->name, "ep%d", i);
+		ep->ep.name = ep->name;
+		if (i == 0)
+			ep->ep.caps.type_control = true;
+		else if (i < 6)
+			ep->ep.caps.type_bulk = true;
+		else if (i < 10)
+			ep->ep.caps.type_int = true;
+		else
+			ep->ep.caps.type_iso = true;
+
+		ep->ep.caps.dir_in = true;
+		ep->ep.caps.dir_out = true;
+
+		ep->has_dma = !!(readl(&chip->regs->usbssconf) & (1 << i));
+		usb_ep_set_maxpacket_limit(&ep->ep, (unsigned short) ~0);
+
+		INIT_LIST_HEAD(&ep->queue);
+		spin_lock_init(&ep->lock);
+
+		if (ep->id == 0) {
+			usbf_ep0_init(ep);
+		} else {
+			usbf_epn_init(ep);
+			list_add_tail(&ep->ep.ep_list,
+				      &chip->gadget.ep_list);
+		}
+	}
+
+	/* Finish initialization by getting possible overrides from DT */
+	if (np) {
+		of_property_read_u32(np,
+				"renesas,dma-threshold", &chip->dma_threshold);
+		of_property_read_u32(np,
+				"renesas,sram-size", &chip->dma_ram_size);
+	}
+
+	/* Not specifying the sram size of the IP is not a problem per se,
+	 * however if you run out your configuration of endpoint over allocates
+	 * there will be no way to know, and you will have silent failure */
+	if (!chip->dma_ram_size)
+		dev_warn(chip->dev,
+			"unknown SRAM size, any overflow will be silent\n");
+
+	/* Tasklet and associated FIFO */
+	tasklet_init(&chip->tasklet, usbf_tasklet,
+			(unsigned long)chip);
+	INIT_KFIFO(chip->fifo);
+
+	/* request irqs */
+	chip->usb_epc_irq = irq_of_parse_and_map(np, 0);
+	if (!chip->usb_epc_irq) {
+		ret = -EINVAL;
+		goto err_noirq;
+	}
+	ret = devm_request_irq(chip->dev, chip->usb_epc_irq, usbf_epc_irq, 0,
+				driver_name, chip);
+	if (ret) {
+		dev_err(chip->dev, "cannot request irq %d err %d\n",
+				chip->usb_epc_irq, ret);
+		goto err_noirq;
+	}
+
+	chip->usb_irq = irq_of_parse_and_map(np, 1);
+	if (!chip->usb_irq) {
+		ret = -EINVAL;
+		goto err_noirq;
+	}
+	ret = devm_request_irq(chip->dev, chip->usb_irq, usbf_irq, 0,
+				driver_name, chip);
+	if (ret) {
+		dev_err(chip->dev, "cannot request irq %d err %d\n",
+				chip->usb_irq, ret);
+		goto err_noirq;
+	}
+
+	writel(readl(&chip->regs->sysmctr) | D_SYS_WBURST_TYPE, &chip->regs->sysmctr);
+
+	writel(D_USB_INT_SEL | D_USB_SOF_RCV | D_USB_SOF_CLK_MODE, &chip->regs->control);
+
+	/* Enable reset and mode change interrupts */
+	writel(D_USB_USB_RST_EN | D_USB_SPEED_MODE_EN, &chip->regs->int_enable);
+	/* Endpoint zero is always enabled anyway */
+	usbf_ep_enable(&chip->ep[0].ep, &ep0_desc);
+
+	ret = usb_add_gadget_udc_release(&ofdev->dev, &chip->gadget,
+			usbf_release);
+	if (ret)
+		goto err5;
+
+	platform_set_drvdata(ofdev, chip);
+
+	writel(D_SYS_VBUS_INTEN, &chip->regs->sysbinten);
+#ifdef DEBUG
+	for (i = 0; i < CFG_NUM_ENDPOINTS; ++i) {
+		struct f_endpoint *ep = chip->ep + i;
+		struct f_regs_ep *ep_reg = &chip->regs->ep[ep->id - 1];
+
+		TRACE("%s %s %08x\n", ep->name,
+			(readl(&chip->regs->usbssconf) & (1 << i)) ?
+					"DMA" : "(no DMA)",
+			readl(&ep_reg->pckt_adrs));
+	}
+#endif
+	pr_info("%s completed (gadget %s)\n", __func__, chip->gadget.name);
+
+#ifdef	CONFIG_DEBUG_FS
+	usbf = chip;
+#endif
+
+	return 0;
+err5:
+err_noirq:
+	clk_disable_unprepare(chip->clk_fw);
+invalid_config:
+clk_failed:
+invalid_mapping:
+	return ret;
+}
+
+static int usbf_remove(struct platform_device *ofdev)
+{
+	struct f_drv *chip = platform_get_drvdata(ofdev);
+	DECLARE_COMPLETION(done);
+
+	TRACE("%s\n", __func__);
+
+	usb_del_gadget_udc(&chip->gadget);
+
+	chip->done = &done;
+	tasklet_disable(&chip->tasklet);
+
+	/* remove the pullup, apparently putting the controller
+	 * in reset doesn't do it! */
+	pullup(chip, 0);
+	/* get back into reset */
+	writel(readl(&chip->regs->epctr) | D_SYS_EPC_RST | D_SYS_PLL_RST,
+			&chip->regs->epctr);
+
+	devm_free_irq(chip->dev, chip->usb_irq, chip);
+	irq_dispose_mapping(chip->usb_irq);
+	devm_free_irq(chip->dev, chip->usb_epc_irq, chip);
+	irq_dispose_mapping(chip->usb_epc_irq);
+
+	tasklet_kill(&chip->tasklet);
+
+	iounmap(chip->regs);
+
+	/* wait for release() of gadget.dev to free udc */
+	wait_for_completion(&done);
+	clk_unprepare(chip->clk_fw);
+
+	return 0;
+}
+
+#ifdef	CONFIG_DEBUG_FS
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+
+static const char *ep_status[2][32] = { {
+	"SETUP_INT",
+	"STG_START_INT",
+	"STG_END_INT",
+	"STALL_INT",
+	"IN_INT",
+	"OUT_INT",
+	"OUT_OR_INT",
+	"OUT_NULL_INT",
+	"IN_EMPTY",
+	"IN_FULL",
+	"IN_DATA",
+	"IN_NAK_INT",
+	"OUT_EMPTY",
+	"OUT_FULL",
+	"OUT_NULL",
+	"OUT_NAK_INT",
+	"PERR_NAK_INT",
+	"PERR_NAK",
+	"PID",
+},
+{
+	"IN_EMPTY",
+	"IN_FULL",
+	"IN_DATA",
+	"IN_INT",
+	"IN_STALL_INT",
+	"IN_NAK_ERR_INT",
+	"(6)",
+	"IN_END_INT",
+	"(8)", "(9)",
+	"IPID",
+	"(11)", "(12)", "(13)", "(14)", "(15)",
+	"OUT_EMPTY",
+	"OUT_FULL",
+	"OUT_NULL_INT",
+	"OUT_INT",
+	"OUT_STALL_INT",
+	"OUT_NAK_ERR_INT",
+	"OUT_OR_INT",
+	"OUT_END_INT",
+	"(24)", "(25)", "(26)", "(27)",
+	"OPID",
+} };
+
+static ssize_t _usbf_dbg_show(struct seq_file *s, void *unused)
+{
+	struct f_drv *chip = usbf;
+	int i;
+
+	seq_puts(s, "USBF Driver Configuration\n");
+
+	for (i = 0; i < CFG_NUM_ENDPOINTS; ++i) {
+		struct f_endpoint *ep = chip->ep + i;
+		struct f_regs_ep *regs =
+			i ? ep->reg :
+			(struct f_regs_ep *)&chip->regs->ep0;
+		uint32_t reg[2] = {
+			readl(&regs->status),
+			ep->status };
+		int ri;
+
+		if (ep->disabled)
+			continue;
+		seq_printf(s, "%s: dir:%s status %08x/%08x seq:%02x %s%s: ",
+			ep->name,
+			usb_endpoint_dir_in(ep->desc) ? "input" : "output",
+			reg[0], reg[1], ep->seq,
+			ep->trace ? "TRACE " : "",
+			list_empty(&ep->queue) ? "(empty)" : "(queued)"
+			);
+		if (!list_empty(&ep->queue)) {
+			struct f_req *req = list_first_entry(&ep->queue,
+							struct f_req, queue);
+
+			seq_printf(s, "[%02x%s]:%d/%d bytes",
+				req->seq,
+				req->req.status == -EBUSY ? " DMA" :
+					req->req.status == 0 ? " DONE?!" : "",
+				req->req.actual, req->req.length);
+		}
+		seq_puts(s, "\n   >");
+
+		for (ri = 0; ri < 2; ri++) {
+			uint32_t r = reg[ri];
+			int ci = 0;
+
+			seq_puts(s, "\n   >");
+			while (r) {
+				int b = ffs(r) - 1;
+
+				r &= ~(1 << b);
+				if (ep_status[!!i][b])
+					seq_printf(s, "%s ", ep_status[!!i][b]);
+				else
+					seq_printf(s, "[%d] ", b);
+				ci = (ci + 1) % 6;
+				if (!ci && r)
+					seq_printf(s, "\n        ");
+			}
+		}
+		seq_puts(s, "\n");
+	}
+
+	return 0;
+}
+
+static int _usbf_dbg_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, _usbf_dbg_show, &inode->i_private);
+}
+
+static const struct file_operations _fops = {
+	.open		= _usbf_dbg_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int usbf_debugfs_ops_ep_trace_show(void *data, uint64_t *value)
+{
+	struct f_drv *chip = usbf;
+	int i;
+
+	*value = 0;
+
+	for (i = 0; i < CFG_NUM_ENDPOINTS; ++i) {
+		struct f_endpoint *ep = chip->ep + i;
+
+		*value |= ep->trace << i;
+	}
+
+	return 0;
+}
+
+static int usbf_debugfs_ops_ep_trace_set(void *data, uint64_t value)
+{
+	struct f_drv *chip = usbf;
+	int i;
+
+	for (i = 0; i < CFG_NUM_ENDPOINTS; ++i) {
+		struct f_endpoint *ep = chip->ep + i;
+
+		ep->trace = !!(value & (1 << i));
+	}
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(usbf_debugfs_ops_ep_trace,
+	usbf_debugfs_ops_ep_trace_show,
+	usbf_debugfs_ops_ep_trace_set,
+	"%llu\n");
+
+static int __init usbf_debug_init(void)
+{
+	struct dentry *dir = debugfs_create_dir("usbf", NULL);
+
+	debugfs_create_file("regs", S_IRUGO, dir, NULL, &_fops);
+
+	debugfs_create_file("ep_trace", S_IWUGO | S_IRUGO, dir, NULL,
+				&usbf_debugfs_ops_ep_trace);
+
+	return 0;
+}
+
+late_initcall(usbf_debug_init);
+#endif /* CONFIG_DEBUG_FS */
+
+/*-------------------------------------------------------------------------*/
+static const struct of_device_id usbf_match[] = {
+	{ .compatible = "renesas,rzn1-usbf", },
+	{ .compatible = "renesas,usbf", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, usbf_match);
+
+static struct platform_driver udc_driver = {
+	.driver = {
+		.name = driver_name,
+		.owner = THIS_MODULE,
+		.of_match_table = usbf_match,
+	},
+	.probe          = usbf_probe,
+	.remove         = usbf_remove,
+};
+
+module_platform_driver(udc_driver);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/gadget/udc/usbf-renesas.h b/drivers/usb/gadget/udc/usbf-renesas.h
new file mode 100644
index 0000000..d9fe77e
--- /dev/null
+++ b/drivers/usb/gadget/udc/usbf-renesas.h
@@ -0,0 +1,614 @@
+/*
+ * Renesas RZ/N1 USB Device usb gadget driver
+ *
+ * Copyright 2015 Renesas Electronics Europe Ltd.
+ * Author: Michel Pollet <michel.pollet@bp.renesas.com>,<buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef __USBF_RENESAS_H__
+#define __USBF_RENESAS_H__
+
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/types.h>
+#include <linux/usb/gadget.h>
+
+#ifdef DEBUG
+#define TRACE(...) printk(__VA_ARGS__)
+#define TRACERQ(_rq, ...) if ((_rq) && (_rq)->trace) printk(__VA_ARGS__)
+#define TRACEEP(_ep, ...) if ((_ep) && (_ep)->trace) printk(__VA_ARGS__)
+#else
+#define TRACE(...)
+#define TRACERQ(_rq, ...)
+#define TRACEEP(_rq, ...)
+#endif
+
+#define CFG_NUM_ENDPOINTS		16
+#define CFG_EP0_MAX_PACKET_SIZE		64
+#define CFG_EPX_MAX_PACKET_SIZE		512
+#define CFG_EPX_MAX_PACKET_CNT		256
+#define EP0_RAM_USED			0x20	/* 32 bits words */
+
+/*
+ * io block register for endpoint zero. Annoyingly enough, it differs
+ * from all the other endpoints.
+ */
+struct f_regs_ep0 {
+	/* these 3 are common with every other endpoint */
+	uint32_t control;		/* EP0 control register */
+	uint32_t status;		/* EP0 status register */
+	uint32_t int_enable;		/* EP0 interrupt enable register */
+
+	uint32_t length;		/* EP0 length register */
+	uint32_t read;			/* EP0 read register */
+	uint32_t write;			/* EP0 write register */
+};
+
+/*
+ * io block register for endpoint 1-15
+ */
+struct f_regs_ep {
+	/* these 3 are common with every other endpoint */
+	uint32_t control;		/* EPn control register */
+	uint32_t status;		/* EPn status register */
+	uint32_t int_enable;		/* EPn interrupt enable register */
+
+	uint32_t dma_ctrl;		/* EPn DMA control register */
+	uint32_t pckt_adrs;		/* EPn max packet & base address register */
+	uint32_t len_dcnt;		/* EPn length & DMA count register */
+	uint32_t read;			/* EPn read register */
+	uint32_t write;			/* EPn write register */
+};
+
+struct f_regs_epdma {
+	uint32_t epndcr1;		/* EPnDCR1 register */
+	uint32_t epndcr2;		/* EPnDCR2 register */
+	uint32_t epntadr;		/* EPnTADR register */
+	uint32_t padding;
+};
+
+/* IO registers for the USB device Ip block */
+struct f_regs {
+	/* The first block of register is 0x1000 long, so we make sure
+	 * it is padded to that size. Use of anonymous union makes it
+	 * painless here
+	 */
+	union {
+		struct {
+			uint32_t control;		/* USB Control register */
+			uint32_t status;		/* USB Status register */
+			uint32_t address;		/* Frame number & USB address register */
+			uint32_t reserved;
+			uint32_t test_control;		/* TEST control register */
+			uint32_t reserved1;
+			uint32_t setup_data0;		/* Setup Data 0 register */
+			uint32_t setup_data1;		/* Setup Data 1 register */
+			uint32_t int_status;		/* USB interrupt status register */
+			uint32_t int_enable;		/* USB interrupt enable register */
+			struct f_regs_ep0 ep0;
+			/* Index zero in this table is for EP1's register, not EP0 */
+			struct f_regs_ep ep[15];
+		};
+		uint8_t pad[0x1000];
+	};
+	/* Follows are the system registers at offset 0x1000 */
+	union {
+		struct {
+			union {	/* Offset 0x1000 */
+				struct {
+					uint32_t syssctr;		/* AHBSCTR register */
+					uint32_t sysmctr;		/* AHBMCTR register */
+					uint32_t sysbint;		/* AHBBINT register */
+					uint32_t sysbinten;		/* AHBBINTEN register */
+					uint32_t epctr;			/* EPCTR register */
+				};
+				uint8_t pada[0x20];
+			};
+			/* Offset 0x1020 */
+			uint32_t usbssver;
+			uint32_t usbssconf;
+		};
+		uint8_t	padb[0x100];
+	};
+	/* Index zero in this table is for EP0's (unused) registers */
+	struct f_regs_epdma epdma[16];	/* Offset 0x1100 */
+};
+
+
+struct f_req;
+struct f_endpoint;
+struct f_drv;
+
+enum {
+	USBF_PROCESS_PIO = 0,
+	USBF_PROCESS_DMA,
+	USBF_PROCESS_METHOD_COUNT
+};
+
+/* packet processor callback for the requests, return 0 when request is done */
+typedef int (*f_req_process_p)(struct f_endpoint *ep, struct f_req *);
+
+/* Endpoint 'driver', allows top level code to be endpoint agnostic */
+struct f_endpoint_drv {
+	int (*enable)(struct f_endpoint *ep);
+	void (*disable)(struct f_endpoint *ep);
+
+	void (*set_maxpacket)(struct f_endpoint *ep);
+
+	/* receive and send callbacks for this kind of endpoint
+	 * PIO is mandatory */
+	f_req_process_p recv[USBF_PROCESS_METHOD_COUNT];
+	f_req_process_p send[USBF_PROCESS_METHOD_COUNT];
+
+	void (*dma_complete)(struct f_endpoint *ep);
+
+	/* handle interrupt status changes */
+	void (*interrupt)(struct f_endpoint *ep);
+
+	int (*halt)(struct f_endpoint *ep, int halt);
+
+	void (*reset)(struct f_endpoint *ep);
+};
+
+/*
+ * USB Queued request, can be read/write, and will definitely be
+ * bigger than the max packet in an endpoint. the 'process' callback
+ * is called repeatedly to fulfill the request (ie, req->actual ==
+ * req->length) and will return 0 when it is, it is then ready to
+ * be 'completed' by the upper layer
+ */
+struct f_req {
+	struct usb_request		req;
+	struct list_head		queue;
+	/* callback used to receive or send this request */
+	f_req_process_p			process;
+	unsigned			use_dma: 1, mapped:1, to_host : 1;
+	unsigned			seq: 8, trace : 1; /* debug */
+	uint8_t				dma_pkt_count;
+	uint32_t			dma_non_burst_bytes;
+};
+
+/*
+ * Type of hardware endpoints
+ */
+enum {
+	USBF_EP_BULK = 0,
+	USBF_EP_INT,
+	USBF_EP_ISO,
+	USBF_EP_KIND_COUNT
+};
+
+/* USB Endpoint structure, with callbacks for send/receive etc */
+struct f_endpoint {
+	struct usb_ep			ep;
+	spinlock_t			lock; /* protect the struct */
+	/* endpoint specific callbacks */
+	const struct f_endpoint_drv	*drv;
+	char				name[32]; /* full endpoint name */
+	struct list_head		queue;
+	struct usb_endpoint_descriptor *desc;
+	struct f_drv			*chip;
+	struct f_regs_ep		*reg;
+	unsigned			id : 8;
+	unsigned			type : 2;	/* EP type */
+	unsigned			max_nr_pkts: 4;	/* default to 2 */
+	unsigned			has_dma: 1;	/* Is DMA capable */
+	unsigned			disabled : 1;
+	unsigned			seq : 8;	/* debug */
+	unsigned			trace : 1;	/* debug */
+	unsigned			trace_min: 10, trace_max: 10;
+	/* cumulative status, populated by the irq handler */
+	uint32_t			status;
+};
+
+/*
+ * We need to copy, and clear the status registers for everyone
+ * before the real interrupt line is cleared, this is a bit
+ * cumbersome but, there is no way around it otherwise the IRQ
+ * keeps firing
+ */
+struct f_status {
+	uint32_t			int_status;	/* global */
+	uint32_t			ep[16];	/* of the endpoints */
+};
+
+struct f_drv {
+	struct usb_gadget		gadget;
+	struct usb_gadget_driver	*driver;
+	struct device			*dev;
+	struct clk			*clk_fw;
+	spinlock_t			lock; /* protect the struct */
+	struct f_regs __iomem		*regs;
+	uint16_t			dma_ram_used;	/* in 32 bits words */
+	u32				dma_ram_size;	/* in 32 bits words */
+	u32				dma_threshold;
+	/* default number of packets, for each endpoints types */
+	uint8_t				dma_pkt_count[USBF_EP_KIND_COUNT];
+
+	struct f_endpoint		ep[CFG_NUM_ENDPOINTS];
+	int				pullup;
+	enum usb_device_state		state;
+
+	/* to make sure release() is done */
+	struct completion 		*done;
+	unsigned int			usb_irq;
+	unsigned int			usb_epc_irq;
+
+	/* for control messages caching */
+	uint32_t			setup[2];
+	struct f_req			setup_reply;
+
+	struct tasklet_struct		tasklet;
+
+	DECLARE_KFIFO(fifo, struct f_status, 16);
+};
+
+int usbf_ep0_init(
+	struct f_endpoint *ep);
+int usbf_epn_init(
+	struct f_endpoint *ep);
+
+int usbf_ep_process_queue(
+	struct f_endpoint *ep);
+
+/*=========================================================================*/
+/* USB_CONTROL [0x000] */
+/*=========================================================================*/
+enum {
+	D_USB_F_RST				= (1 << 0),
+	D_USB_PHY_RST				= (1 << 1),
+	D_USB_PUE2				= (1 << 2),
+	D_USB_CONNECTB				= (1 << 3),
+	D_USB_DEFAULT				= (1 << 4),
+	D_USB_CONF				= (1 << 5),
+	D_USB_SUSPEND				= (1 << 6),
+	D_USB_RSUM_IN				= (1 << 7),
+	D_USB_SOF_RCV				= (1 << 8),
+	D_USB_CONSTFS				= (1 << 9),
+	D_USB_INT_SEL				= (1 << 10),
+	D_USB_SOF_CLK_MODE			= (1 << 11),
+	D_USB_USBTESTMODE			= (1 << 16) | (1 << 17) |
+							(1 << 18),
+};
+
+/*=========================================================================*/
+/* USB_STATUS [0x004] */
+/*=========================================================================*/
+enum {
+	D_USB_VBUS_LEVEL			= (1 << 0),
+	D_USB_RSUM_OUT				= (1 << 1),
+	D_USB_SPND_OUT				= (1 << 2),
+	D_USB_USB_RST				= (1 << 3),
+/*	D_USB_DEFAULT				= (1 << 4),*/
+	D_USB_CONF_ST				= (1 << 5),
+	D_USB_SPEED_MODE			= (1 << 6),
+};
+
+/*=========================================================================*/
+/* USB_ADDRESS [0x008] */
+/*=========================================================================*/
+enum {
+	D_USB_SOF_STATUS			= (1 << 15),
+	D_USB_USB_ADDR				= 0x007F0000,
+};
+
+/*=========================================================================*/
+/* USB_INT_STA [0x020] */
+/*=========================================================================*/
+enum {
+/*	D_USB_VBUS_LEVEL			= (1 << 0), */
+	D_USB_RSUM_INT				= (1 << 1),
+	D_USB_SPND_INT				= (1 << 2),
+	D_USB_USB_RST_INT			= (1 << 3),
+	D_USB_SOF_INT				= (1 << 4),
+	D_USB_SOF_ERROR_INT			= (1 << 5),
+	D_USB_SPEED_MODE_INT			= (1 << 6),
+	D_USB_VBUS_INT				= (1 << 7),
+	D_USB_EP0_INT				= (1 << 8),
+	D_USB_EP1_INT				= (1 << 9),
+	D_USB_EP2_INT				= (1 << 10),
+	D_USB_EP3_INT				= (1 << 11),
+	D_USB_EP4_INT				= (1 << 12),
+	D_USB_EP5_INT				= (1 << 13),
+	D_USB_EP6_INT				= (1 << 14),
+	D_USB_EP7_INT				= (1 << 15),
+	D_USB_EP8_INT				= (1 << 16),
+	D_USB_EP9_INT				= (1 << 17),
+	D_USB_EPN_INT				= 0x00FFFF00,
+};
+
+/*=========================================================================*/
+/* USB_INT_ENA [0x024] */
+/*=========================================================================*/
+enum {
+	D_USB_RSUM_EN				= (1 << 1),
+	D_USB_SPND_EN				= (1 << 2),
+	D_USB_USB_RST_EN			= (1 << 3),
+	D_USB_SOF_EN				= (1 << 4),
+	D_USB_SOF_ERROR_EN			= (1 << 5),
+	D_USB_SPEED_MODE_EN			= (1 << 6),
+	D_USB_VBUS_EN				= (1 << 7),
+	D_USB_EP0_EN				= (1 << 8),
+	D_USB_EP1_EN				= (1 << 9),
+	D_USB_EP2_EN				= (1 << 10),
+	D_USB_EP3_EN				= (1 << 11),
+	D_USB_EP4_EN				= (1 << 12),
+	D_USB_EP5_EN				= (1 << 13),
+	D_USB_EP6_EN				= (1 << 14),
+	D_USB_EP7_EN				= (1 << 15),
+	D_USB_EP8_EN				= (1 << 16),
+	D_USB_EP9_EN				= (1 << 17),
+	D_USB_EPN_EN				= 0x00FFFF00,
+};
+
+/*=========================================================================*/
+/* EP0_CONTROL [0x028] */
+/*=========================================================================*/
+enum {
+	D_EP0_ONAK				= (1 << 0),
+	D_EP0_INAK				= (1 << 1),
+	D_EP0_STL				= (1 << 2),
+	D_EP0_PERR_NAK_CLR			= (1 << 3),
+	D_EP0_INAK_EN				= (1 << 4),
+	D_EP0_DW				= (1 << 5) | (1 << 6),
+	D_EP0_DEND				= (1 << 7),
+	D_EP0_BCLR				= (1 << 8),
+	D_EP0_PIDCLR				= (1 << 9),
+	D_EP0_AUTO				= (1 << 16),
+	D_EP0_OVERSEL				= (1 << 17),
+	D_EP0_STGSEL				= (1 << 18),
+};
+
+/*=========================================================================*/
+/* EP0_STATUS [0x02C] */
+/*=========================================================================*/
+enum {
+	D_EP0_SETUP_INT				= (1 << 0),
+	D_EP0_STG_START_INT			= (1 << 1),
+	D_EP0_STG_END_INT			= (1 << 2),
+	D_EP0_STALL_INT				= (1 << 3),
+	D_EP0_IN_INT				= (1 << 4),
+	D_EP0_OUT_INT				= (1 << 5),
+	D_EP0_OUT_OR_INT			= (1 << 6),
+	D_EP0_OUT_NULL_INT			= (1 << 7),
+	D_EP0_IN_EMPTY				= (1 << 8),
+	D_EP0_IN_FULL				= (1 << 9),
+	D_EP0_IN_DATA				= (1 << 10),
+	D_EP0_IN_NAK_INT			= (1 << 11),
+	D_EP0_OUT_EMPTY				= (1 << 12),
+	D_EP0_OUT_FULL				= (1 << 13),
+	D_EP0_OUT_NULL				= (1 << 14),
+	D_EP0_OUT_NAK_INT			= (1 << 15),
+	D_EP0_PERR_NAK_INT			= (1 << 16),
+	D_EP0_PERR_NAK				= (1 << 17),
+	D_EP0_PID				= (1 << 18),
+};
+
+/*=========================================================================*/
+/* EP0_INT_ENA [0x030] */
+/*=========================================================================*/
+enum {
+	D_EP0_SETUP_EN				= (1 << 0),
+	D_EP0_STG_START_EN			= (1 << 1),
+	D_EP0_STG_END_EN			= (1 << 2),
+	D_EP0_STALL_EN				= (1 << 3),
+	D_EP0_IN_EN				= (1 << 4),
+	D_EP0_OUT_EN				= (1 << 5),
+	D_EP0_OUT_OR_EN				= (1 << 6),
+	D_EP0_OUT_NULL_EN			= (1 << 7),
+	D_EP0_IN_NAK_EN				= (1 << 11),
+	D_EP0_OUT_NAK_EN			= (1 << 15),
+	D_EP0_PERR_NAK_EN			= (1 << 16),
+};
+
+/*=========================================================================*/
+/* EP0_LENGTH [0x034] */
+/*=========================================================================*/
+enum {
+	D_EP0_LDATA				= 0x0000007F,
+};
+
+/*=========================================================================*/
+/* EPN_CONTROL_BIT */
+/*=========================================================================*/
+enum {
+	D_EPN_ONAK				= (1 << 0),
+	D_EPN_OSTL				= (1 << 2),
+	D_EPN_ISTL				= (1 << 3),
+	D_EPN_OSTL_EN				= (1 << 4),
+	D_EPN_DW				= (1 << 5) | (1 << 6),
+	D_EPN_DEND				= (1 << 7),
+	D_EPN_CBCLR				= (1 << 8),
+	D_EPN_BCLR				= (1 << 9),
+	D_EPN_OPIDCLR				= (1 << 10),
+	D_EPN_IPIDCLR				= (1 << 11),
+	D_EPN_AUTO				= (1 << 16),
+	D_EPN_OVERSEL				= (1 << 17),
+	D_EPN_MODE				= (1 << 24) | (1 << 25),
+	D_EPN_DIR0				= (1 << 26),
+	D_EPN_BUF_TYPE				= (1 << 30),
+	D_EPN_EN				= (1 << 31),
+};
+
+/*=========================================================================*/
+/* EPN_STATUS_BIT */
+/*=========================================================================*/
+enum {
+	D_EPN_IN_EMPTY				= (1 << 0),
+	D_EPN_IN_FULL				= (1 << 1),
+	D_EPN_IN_DATA				= (1 << 2),
+	D_EPN_IN_INT				= (1 << 3),
+	D_EPN_IN_STALL_INT			= (1 << 4),
+	D_EPN_IN_NAK_ERR_INT			= (1 << 5),
+	D_EPN_IN_END_INT			= (1 << 7),
+	D_EPN_IPID				= (1 << 10),
+	D_EPN_OUT_EMPTY				= (1 << 16),
+	D_EPN_OUT_FULL				= (1 << 17),
+	D_EPN_OUT_NULL_INT			= (1 << 18),
+	D_EPN_OUT_INT				= (1 << 19),
+	D_EPN_OUT_STALL_INT			= (1 << 20),
+	D_EPN_OUT_NAK_ERR_INT			= (1 << 21),
+	D_EPN_OUT_OR_INT			= (1 << 22),
+	D_EPN_OUT_END_INT			= (1 << 23),
+	D_EPN_OPID				= (1 << 28),
+};
+
+/*=========================================================================*/
+/* EPN_INT_ENA */
+/*=========================================================================*/
+enum {
+	D_EPN_IN_EN				= (1 << 3),
+	D_EPN_IN_STALL_EN			= (1 << 4),
+	D_EPN_IN_NAK_ERR_EN			= (1 << 5),
+	D_EPN_IN_END_EN				= (1 << 7),
+	D_EPN_OUT_NULL_EN			= (1 << 18),
+	D_EPN_OUT_EN				= (1 << 19),
+	D_EPN_OUT_STALL_EN			= (1 << 20),
+	D_EPN_OUT_NAK_ERR_EN			= (1 << 21),
+	D_EPN_OUT_OR_EN				= (1 << 22),
+	D_EPN_OUT_END_EN			= (1 << 23),
+};
+
+/*=========================================================================*/
+/* EPN_DMA_CTRL */
+/*=========================================================================*/
+enum {
+	D_EPN_DMAMODE0				= (1 << 0),
+	D_EPN_DMAMODE2				= (1 << 2),
+	D_EPN_DMA_EN				= (1 << 4),
+	D_EPN_STOP_SET				= (1 << 8),
+	D_EPN_BURST_SET				= (1 << 9),
+	D_EPN_DEND_SET				= (1 << 10),
+	D_EPN_STOP_MODE				= (1 << 11),
+	D_EPN_BUS_SEL				= (1 << 12) | (1 << 13),
+};
+
+/*=========================================================================*/
+/* EPN_PCKT_ADRS */
+/*=========================================================================*/
+enum {
+	D_EPN_MPKT				= 0x000007FF,
+	D_EPN_BASEAD				= 0x1FFF0000,
+};
+
+/*=========================================================================*/
+/* EPN_LEN_DCNT */
+/*=========================================================================*/
+enum {
+	D_EPN_LDATA				= 0x000007FF,
+	D_EPN_DMACNT				= 0x01FF0000,
+};
+
+
+/*=========================================================================*/
+/* SYSSCTR [0x1000] */
+/*=========================================================================*/
+enum {
+	D_SYS_WAIT_MODE				= (1 << 0),
+	D_SYS_NOT_RETRY_MASTER			= 0xFFFF0000,
+};
+
+/*=========================================================================*/
+/* SYSMCTR [0x1004] */
+/*=========================================================================*/
+enum {
+	D_SYS_ARBITER_CTR			= (1 << 31),
+	D_SYS_WBURST_TYPE			= (1 << 2),
+};
+
+/*=========================================================================*/
+/* SYSBINT [0x1008] */
+/*=========================================================================*/
+enum {
+	D_SYS_ERR_MASTER			= 0x0000000F,
+	D_SYS_SBUS_ERRINT0			= (1 << 4),
+	D_SYS_SBUS_ERRINT1			= (1 << 5),
+	D_SYS_MBUS_ERRINT			= (1 << 6),
+	D_SYS_VBUS_INT				= (1 << 13),
+	D_SYS_DMA_ENDINT_EP1			= (1 << 17),
+	D_SYS_DMA_ENDINT_EP2			= (1 << 18),
+	D_SYS_DMA_ENDINT_EP3			= (1 << 19),
+	D_SYS_DMA_ENDINT_EP4			= (1 << 20),
+	D_SYS_DMA_ENDINT_EP5			= (1 << 21),
+	D_SYS_DMA_ENDINT_EP6			= (1 << 22),
+	D_SYS_DMA_ENDINT_EP7			= (1 << 23),
+	D_SYS_DMA_ENDINT_EP8			= (1 << 24),
+	D_SYS_DMA_ENDINT_EP9			= (1 << 25),
+	D_SYS_DMA_ENDINT_EPN			= 0xFFFE0000,
+};
+
+/*=========================================================================*/
+/* SYSBINTEN [ 0x100C ] */
+/*=========================================================================*/
+enum {
+	D_SYS_SBUS_ERRINT0EN			= (1 << 4),
+	D_SYS_SBUS_ERRINT1EN			= (1 << 5),
+	D_SYS_MBUS_ERRINTEN			= (1 << 6),
+	D_SYS_VBUS_INTEN			= (1 << 13),
+	D_SYS_DMA_ENDINTEN_EP1			= (1 << 17),
+	D_SYS_DMA_ENDINTEN_EP2			= (1 << 18),
+	D_SYS_DMA_ENDINTEN_EP3			= (1 << 19),
+	D_SYS_DMA_ENDINTEN_EP4			= (1 << 20),
+	D_SYS_DMA_ENDINTEN_EP5			= (1 << 21),
+	D_SYS_DMA_ENDINTEN_EP6			= (1 << 22),
+	D_SYS_DMA_ENDINTEN_EP7			= (1 << 23),
+	D_SYS_DMA_ENDINTEN_EP8			= (1 << 24),
+	D_SYS_DMA_ENDINTEN_EP9			= (1 << 25),
+	D_SYS_DMA_ENDINTEN_EPN			= 0xFFFE0000,
+};
+
+/*=========================================================================*/
+/* EPCTR [ 0x1010 ] */
+/*=========================================================================*/
+enum {
+	D_SYS_EPC_RST				= (1 << 0),
+	D_SYS_USBH_RST				= (1 << 1),
+	D_SYS_PLL_RST				= (1 << 2),
+	D_SYS_PCICLK_MASK			= (1 << 3),
+	D_SYS_PLL_LOCK				= (1 << 4),
+	D_SYS_PLL_RESUME			= (1 << 5),
+	D_SYS_VBUS_LEVEL			= (1 << 8),
+	D_SYS_DIRPD				= (1 << 12),
+};
+
+/*=========================================================================*/
+/* USBSSVER [ 0x1020 ] */
+/*=========================================================================*/
+enum {
+	D_SYS_SS_VER				= 0x000000FF,
+	D_SYS_EPC_VER				= 0x0000FF00,
+	D_SYS_SYSB_VER				= 0x00FF0000,
+};
+
+/*=========================================================================*/
+/* USBSSCONF [ 0x1024 ] */
+/*=========================================================================*/
+enum {
+	D_SYS_DMA_AVAILABLE			= 0x0000FFFF,
+	D_SYS_EP_AVAILABLE			= 0xFFFF0000,
+};
+
+/*=========================================================================*/
+/* DCR1 */
+/*=========================================================================*/
+enum {
+	D_SYS_EPN_REQEN				= (1 << 0),
+	D_SYS_EPN_DIR0				= (1 << 1),
+	D_SYS_EPN_DMACNT			= 0x00FF0000,
+};
+
+/*=========================================================================*/
+/* DCR2 */
+/*=========================================================================*/
+enum {
+	D_SYS_EPN_MPKT				= 0x000007FF,
+	D_SYS_EPN_LMPKT				= 0x07FF0000,
+};
+
+#endif /* __USBF_RENESAS_H__ */
-- 
2.7.4

