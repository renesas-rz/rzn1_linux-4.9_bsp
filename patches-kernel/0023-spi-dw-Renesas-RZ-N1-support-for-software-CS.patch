From 7c49b4a2a458aeb0ad496f6e7bfd05a49ceead5a Mon Sep 17 00:00:00 2001
From: Michel Pollet <michel.pollet@bp.renesas.com>
Date: Tue, 19 Jan 2016 09:12:32 +0000
Subject: [PATCH] spi-dw: Renesas RZ/N1 support for 'software CS'

Add support for this version of the IP, it adds a mode where the CS
lines are driven by the driver and not the IP; this allows support for
flash chips and other devices that requires 'write then read'
transactions.

Signed-off-by: Michel Pollet <michel.pollet@bp.renesas.com>
---
 Documentation/devicetree/bindings/spi/spi-dw.txt |  7 ++++++
 drivers/spi/Kconfig                              | 18 ++++++++++++++++
 drivers/spi/spi-dw-mmio.c                        | 27 ++++++++++++++++++++++++
 drivers/spi/spi-dw.c                             | 23 +++++++++++++++++++-
 drivers/spi/spi-dw.h                             | 12 +++++++++++
 5 files changed, 86 insertions(+), 1 deletion(-)

diff --git a/Documentation/devicetree/bindings/spi/spi-dw.txt b/Documentation/devicetree/bindings/spi/spi-dw.txt
index 7b63ed6..10cf7bb 100644
--- a/Documentation/devicetree/bindings/spi/spi-dw.txt
+++ b/Documentation/devicetree/bindings/spi/spi-dw.txt
@@ -11,6 +11,12 @@ Required properties:
 
 Optional properties:
 - cs-gpios: see spi-bus.txt
+- renesas,rzn1-cs-mode: specify software/hardware modes for CS lines.
+  This version of the controller has a 'software mode' that allows the
+  SPI layer to control the CS line as it sees fit, instead of letting the
+  hardware toggle it -- this is necessary for talking to flash chips, eeproms
+  etc. The value is a bitfield, with bits corresponds to individual lines, and
+  '1' means 'use software CS' and 0 means 'default to hardware mode'.
 
 Example:
 
@@ -21,4 +27,5 @@ spi: spi@4020a000 {
 	clocks = <&pclk>;
 	num-cs = <2>;
 	cs-gpios = <&banka 0 0>;
+	renesas,rzn1-cs-mode = <0x3>;
 };
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 46e971d..6034ae6 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -234,6 +234,24 @@ config SPI_DW_MMIO_MUXED
 	bool "Allow the driver to activate a pin state per transaction"
 	depends on SPI_DW_MMIO
 
+config SPI_DW_RZN1
+	bool "Implement Renesas RZ/N1 extra mode for Chip Select"
+	depends on SPI_DW_MMIO
+	depends on ARCH_RZN1
+	default y
+	help
+	  Renesas RZ/N1 has a 'software' mode for chip select.
+
+	  DW SPI normal implementation has 'hardware' chip select that
+	  automatically enables and resets the CS line between transactions,
+	  or when the FIFO is empty.
+	  This prevents using the IP for making full duplex transactions, like
+	  the ones used to talk to flash/eeproms and so on.
+	  RZ/N1 IP implementation has a 'software' mode that allows the driver
+	  to have more finely grained control on the CS lines, by saying 'Y'
+	  here the driver will default to the software mode, but can still
+	  be overridden by the device tree block.
+
 config SPI_DLN2
        tristate "Diolan DLN-2 USB SPI adapter"
        depends on MFD_DLN2
diff --git a/drivers/spi/spi-dw-mmio.c b/drivers/spi/spi-dw-mmio.c
index 447497e..3da06c8 100644
--- a/drivers/spi/spi-dw-mmio.c
+++ b/drivers/spi/spi-dw-mmio.c
@@ -78,6 +78,33 @@ static int dw_spi_mmio_probe(struct platform_device *pdev)
 
 	dws->num_cs = num_cs;
 
+#ifdef CONFIG_SPI_DW_RZN1
+	/* default to sw mode on that platform, the HW mode is next to useless
+	 * for most purposes */
+	dws->mode = (1 << dws->num_cs) -1;
+	if (pdev->dev.of_node) {
+		struct device_node *child = NULL;
+
+		of_property_read_u32(pdev->dev.of_node,
+			"renesas,rzn1-cs-mode", &dws->mode);
+		/* Also check the mode in each of the separate child nodes */
+		for_each_available_child_of_node(pdev->dev.of_node, child) {
+			u32 addr;
+			int ret = of_property_read_u32(child, "reg", &addr);
+
+			if (ret || addr >= dws->num_cs) {
+				dev_warn(&pdev->dev, "invalid slave %s",
+					child->name);
+				continue;
+			}
+			if (of_property_read_bool(child, "renesas,rzn1-cs-sw"))
+				dws->mode |= (1 << addr);
+			if (of_property_read_bool(child, "renesas,rzn1-cs-hw"))
+				dws->mode &= ~(1 << addr);
+		}
+	}
+#endif
+
 	if (pdev->dev.of_node) {
 		int i;
 
diff --git a/drivers/spi/spi-dw.c b/drivers/spi/spi-dw.c
index fafab96..4f7db89 100644
--- a/drivers/spi/spi-dw.c
+++ b/drivers/spi/spi-dw.c
@@ -136,7 +136,10 @@ static void dw_spi_set_cs(struct spi_device *spi, bool enable)
 {
 	struct dw_spi *dws = spi_master_get_devdata(spi->master);
 	struct chip_data *chip = spi_get_ctldata(spi);
-
+#ifdef CONFIG_SPI_DW_RZN1
+	int cs;
+	u32 reg;
+#endif
 	/* Chip select logic is inverted from spi_set_cs() */
 #ifdef CONFIG_SPI_DW_MMIO_MUXED
 	if (dws->pinon)
@@ -146,8 +149,20 @@ static void dw_spi_set_cs(struct spi_device *spi, bool enable)
 	if (chip && chip->cs_control)
 		chip->cs_control(!enable);
 
+#ifdef CONFIG_SPI_DW_RZN1
+	/* RZN1 version of the IP can be configured to use a 'software mode'
+	 * in which case the CS bit is just shifted 4 bits up, and the lower
+	 * 4 bits are ignored */
+	cs = spi->chip_select + ((dws->mode & (1 << spi->chip_select)) ?
+			DW_SPI_SER_SW_OFFSET : DW_SPI_SER_HW_OFFSET);
+	reg = (dw_readl(dws, DW_SPI_SER) &
+		~((1 << cs) | (1 << spi->chip_select)));
+	reg |= (!enable << cs) | (!enable << spi->chip_select);
+	dw_writel(dws, DW_SPI_SER, reg);
+#else
 	if (!enable)
 		dw_writel(dws, DW_SPI_SER, BIT(spi->chip_select));
+#endif
 }
 
 /* Return the max entries we can fill into tx fifo */
@@ -471,6 +486,12 @@ static void spi_hw_init(struct device *dev, struct dw_spi *dws)
 		dws->fifo_len = (fifo == 1) ? 0 : fifo;
 		dev_dbg(dev, "Detected FIFO size: %u bytes\n", dws->fifo_len);
 	}
+#ifdef CONFIG_SPI_DW_RZN1
+	dev_dbg(dev, "RZ/N1 CS Config: 0x%x (%04x)\n", dws->mode,
+		dw_readl(dws, DW_SPI_SER));
+	/* Mark the software ones */
+	dw_writel(dws, DW_SPI_SER, dws->mode << DW_SPI_SER_CS_CONF_OFFSET);
+#endif
 }
 
 int dw_spi_add_host(struct device *dev, struct dw_spi *dws)
diff --git a/drivers/spi/spi-dw.h b/drivers/spi/spi-dw.h
index c6808e4..94dba02 100644
--- a/drivers/spi/spi-dw.h
+++ b/drivers/spi/spi-dw.h
@@ -147,7 +147,19 @@ struct dw_spi {
 	struct pinctrl 		*pinctrl;
 	struct pinctrl_state 	*pinon;
 #endif
+#ifdef CONFIG_SPI_DW_RZN1
+	/* bitfield, bit is 1 for software mode, 0 for hardware mode */
+	u32			mode;
+#endif
+};
+
+#ifdef CONFIG_SPI_DW_RZN1
+enum {
+	DW_SPI_SER_HW_OFFSET 	= 0,
+	DW_SPI_SER_SW_OFFSET 	= 4,
+	DW_SPI_SER_CS_CONF_OFFSET 	= 8,
 };
+#endif
 
 static inline u32 dw_readl(struct dw_spi *dws, u32 offset)
 {
-- 
2.7.4

