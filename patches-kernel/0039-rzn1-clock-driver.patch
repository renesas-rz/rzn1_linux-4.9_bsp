From 39eb19d3767fdd1f704b2d93b1cce7da46bd0b22 Mon Sep 17 00:00:00 2001
From: Michel Pollet <michel.pollet@bp.renesas.com>
Date: Tue, 14 Jul 2015 10:13:44 +0100
Subject: [PATCH] rzn1: clock driver

Clock tree infrastructure for the RZN1

Signed-off-by: Michel Pollet <michel.pollet@bp.renesas.com>
---
 .../bindings/clock/renesas,rzn1-clocks.txt         | 241 +++++++++++++++++
 drivers/clk/Makefile                               |   1 +
 drivers/clk/rzn1/Makefile                          |   7 +
 drivers/clk/rzn1/rzn1-clkctrl-tables.h             | 297 +++++++++++++++++++++
 drivers/clk/rzn1/rzn1-clock-bitselect.c            | 285 ++++++++++++++++++++
 drivers/clk/rzn1/rzn1-clock-divider.c              | 271 +++++++++++++++++++
 drivers/clk/rzn1/rzn1-clock-gate.c                 | 109 ++++++++
 drivers/clk/rzn1/rzn1-clock-group.c                | 144 ++++++++++
 drivers/clk/rzn1/rzn1-clock-selector.c             |  77 ++++++
 drivers/clk/rzn1/rzn1-clock.c                      | 260 ++++++++++++++++++
 drivers/clk/rzn1/rzn1-clock.h                      |  54 ++++
 11 files changed, 1746 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/clock/renesas,rzn1-clocks.txt
 create mode 100644 drivers/clk/rzn1/Makefile
 create mode 100644 drivers/clk/rzn1/rzn1-clkctrl-tables.h
 create mode 100644 drivers/clk/rzn1/rzn1-clock-bitselect.c
 create mode 100644 drivers/clk/rzn1/rzn1-clock-divider.c
 create mode 100644 drivers/clk/rzn1/rzn1-clock-gate.c
 create mode 100644 drivers/clk/rzn1/rzn1-clock-group.c
 create mode 100644 drivers/clk/rzn1/rzn1-clock-selector.c
 create mode 100644 drivers/clk/rzn1/rzn1-clock.c
 create mode 100644 drivers/clk/rzn1/rzn1-clock.h

diff --git a/Documentation/devicetree/bindings/clock/renesas,rzn1-clocks.txt b/Documentation/devicetree/bindings/clock/renesas,rzn1-clocks.txt
new file mode 100644
index 0000000..48cb2c5
--- /dev/null
+++ b/Documentation/devicetree/bindings/clock/renesas,rzn1-clocks.txt
@@ -0,0 +1,241 @@
+Renesas RZN1 Clock Binding Documentation
+
+This binding uses the common clock binding[1] with extensions.
+
+[1] Documentation/devicetree/bindings/clock/clock-bindings.txt
+
+1] Rationale
+------------
+The Renesas RZN1 device tree clock structure is mostly autogenerated from the
+specification document. The data was extracted from a variety of such
+documents, with the goal of being able to follow these documents and
+re-generate these files if/when the specification evolves.
+
+A number of clock drivers are in place to handle the various features of the
+clock tree:
+	+ renesas,rzn1-clock is the 'container' driver, it's only real job is to
+	  map the SYSCTRL io block that will be used by all the other
+	  drivers.
+	+ renesas,rzn1-clock-gate is a mapping that creates a generic clk-gate
+	  using the information extracted from the clock gate table (see 3]).
+	+ renesas,rzn1-clock-divider is a driver that is derived from the
+	  generic clk-divider linux driver, but has been simplified in some
+	  ways, and the primary feature it needed was to handle the
+	  SYSCTRL 'BUSY' flag that is paired with each divider in the SYSCTRL
+	  block.
+	+ renesas,rzn1-clock-selector is a mapping that creates a generic
+	  clk-mux for the clock that can have multiple sources.
+	+ renesas,rzn1-clock-bitselect is a clock privider that allows one bit
+	  to change the clock source of multiple sub clocks.
+	+ renesas,rzn1-clock-dualgate is a clock provider that is always a
+	  subclock of a bitselect block, as these clock source have different
+	  clock gates depending on which source is selected (!).
+	+ renesas,rzn1-clock-group is a clock provider that allows multiple
+	  clocks to be claimed and enabled while masquerading as a single
+	  source.
+
+2] Clock Container
+------------------
+The renesas,rzn1-clocks driver exists only to be the first one that is loaded,
+to ensure that the SYSCTRL registers are mapped for all the other sub-drivers
+to use.
+It also provides a /sys/kernel/rzn1/ interface with the following files:
+	+ /sys/kernel/rzn1/clk_set_rate
+	  This file allows userland to change the clock rate of anything that
+	  will allow it. It was mainly made to test the clock infrastructure,
+	  however it could be used for other purposes
+
+3] Clock Gates
+--------------
+The first important piece of data is the clock gates; all of these were
+extracted automatically from the SYSCTRL block documentation. Each of the gates
+was extracted, it's named derived from the register it is in, and an optional
+reset and 'slave ready' bit was also extracted at the same time.
+
+Each of these gates were given a number, and are all listed in the
+	./include/dt-bindings/clock/rzn1-clocks.h file.
+
+For a given rzn1-clocks.h definition, for example:
+
+	#define RZN1_CLK_ADC			24
+
+You will find in rzn1-clkctrl-tables.h in the table that allow reverse mapping
+that arbitrary number to a set of register and bits:
+
+	[RZN1_PCLK_ADC] =
+		_CLK("pclk_adc", _BIT(13, 15), _BIT(13, 16), _BIT(13, 17)),
+
+The _BIT() macro has the register number (as a 32 bit word) in the SYSCTRL
+block, so here '13' means RZN1_SYSCTRL_REG_PWRCTRL_BASICS_0 as defined in
+the file:
+
+	./include/dt-bindings/soc/rzn1-sysctrl.h
+
+The Device Mapping is otherwise very simple:
+	clk_adc: clk_adc {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_ADC>;
+		clocks = <&div_adc>;
+	};
+The <reg> property specifies the clock number, that is all that is needed, the
+driver will map that back to a register/bit pair, and create a clk_gate with
+it.
+
+
+4] Clock Divider
+----------------
+Each divider has a standard format register in SYSCTRL, containing a few
+bits for the divider and a BUSY bit, as bit 31.
+The mapping is therefore pretty easy too:
+	div_adc: div_adc {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0xff>;
+		renesas,rzn1-div-min = <50>;
+		renesas,rzn1-div-max = <250>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_BASICS_ADCDIV>;
+		clocks = <&clkout>;
+	};
+The <renesas,rzn1-bit-mask> specifies the bits that needs to be set in the <reg>
+register. The <reg> register uses a define from the file:
+	./include/dt-bindings/soc/rzn1-sysctrl.h
+The <renesas,rzn1-div-min> and <renesas,rzn1-div-max> are the minimum and
+maximum values for this divider, inclusive.
+
+Some of the clock dividers are not linear, you can't use every divider values
+between min and max, therefore there is an extra property that that specifies
+the set of valid values:
+	rtos_mdc: hw_rtos_mdc: hw_rtos_mdc {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0x3ff>;
+		renesas,rzn1-div-min = <80>;
+		renesas,rzn1-div-max = <640>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_HWRTOS_MDCDIV>;
+		renesas,rzn1-div-table = <80 160 320 640>;
+		clocks = <&clk_ref_sync>;
+	};
+Only the values specified in renesas,rzn1-div-table will be used in that
+register, and the frequency requested will be adjusted to the value that is
+nearest the target value using the corresponding divider value.
+
+5] Clock Selector
+-----------------
+Some clocks can have different source clocks, that source clock is specified by
+a register that is not in the SYSCTRL register block.
+	clk_ptp_mac0: mac0_clk_ptp_ref_i: mac0_clk_ptp_ref_i {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-selector";
+		reg = <0xdeadbeef 4>;
+		renesas,rzn1-bit-mask = <0x3>;
+		renesas,rzn1-bit-shift = <12>;
+		clocks = <&rgmii_refclk>, <&clk125>, <&clk25>, <&clk50>;
+	};
+The 'reg' property specifies a physical address for the register that contains
+the mux bits, the renesas,rzn1-bit-mask contains the mask for that register, and
+the optional renesas,rzn1-bit-shift contains the position the mask should be
+shifted to. If renesas,rzn1-bit-shift is not specified, the
+renesas,rzn1-bit-mask is used to derivate it, so you can write:
+		renesas,rzn1-bit-mask = <0x30>;
+And this will be the equivalent of:
+		renesas,rzn1-bit-mask = <0x3>;
+		renesas,rzn1-bit-shift = <4>;
+NOTE: none of the 'reg' properties for the clock-selector nodes are populated
+at this moment, as the register blocks they are in is currently unknown.
+
+6] Clock Bit-Select
+-------------------
+The renesas,rzn1-clock-bitselect driver exists only to support the 2 groups of
+uarts on the machine. All the uarts can have 2 distinctive clock sources, but
+not independently of each others. One bit will change the clock source of all
+the uarts in that group.
+To make things more complicated, there are 2 clock gates per uart, one for
+each of the potential clock source.
+It sort of looks like this:
+
+    Clock Source 1 -----   bit    /--- Gate 1 Uart 0 --\
+                        \ +---+  /  |- Gate 1 Uart 1    \    +------+
+                         -| 0 |-/   |- Gate 1 Uart 2     \---| dual |-- Uart 0
+                        /-| 1 |-\                        /---| gate |    Clock
+                       /  +---+  \---- Gate 2 Uart 0 ---/    +------+
+    Clock Source 2 ----   select    |- Gate 2 Uart 1
+                                    |- Gate 2 Uart 2           ...
+
+So the purpose of the bit-select and dualgate clocks are to make it appear that
+there is a single gate to turn on/off for each uart, and the driver will know
+which gate to activate/deactivate depending on the bit-select current status.
+Likewise, when the bit-select changes, all the sub clocks dual gate will turn
+off the previous clock source gate, and will turn on the new gate.
+
+The instantiation of a clock-bitselect goes like this:
+	 uart_group_012: uart_group_012 {
+		...
+
+		compatible = "renesas,rzn1-clock-bitselect";
+		/* Bit 24 is UARTCLKSEL */
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_BASICS_0>;
+		renesas,rzn1-sel-bit = <30>;
+
+		/* If that bit is zero, use first parent, else,
+		 * use second parent */
+		clocks = <&div_uart>, <&clk_48>;
+
+		/* First group are gates for when selector bit
+		 * is zero, second group is the gates to use when
+		 * bit is 'one' */
+		renesas,rzn1-gates =
+		      <RZN1_SCLK_UART0 RZN1_SCLK_UART1
+			RZN1_SCLK_UART2>,
+		      <RZN1_SCLK_USB_UART0 RZN1_SCLK_USB_UART1
+			RZN1_SCLK_USB_UART2>;
+		...
+	};
+The <reg> property specifies the name of the SYSCTRL register where the bit is
+defined, and the renesas,rzn1-sel-bit specified which bit it is.
+The renesas,rzn1-gates specifies two groups of 'gates'; the first group is the
+gates that are to be used when the bit is zero, the second group for went the
+bit is 1.
+
+Next come the sub-clock instantiation, the renesas,rzn1-clock-dualgate are
+required to be instantiated in the renesas,rzn1-clock-bitselect block.
+		gsclk_uart0: gsclk_uart0 {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-dualgate";
+			clocks = <&uart_group_012>;
+			reg = <0>;
+		 };
+The 'clocks' property links that clock back to the bitselect group, and the
+'reg' property is the index of the gate to use in the renesas,rzn1-gates
+property.
+
+7] Clock Grouping
+-----------------
+There are a lot of IP blocks that rely on having multiple clocks enabled,
+even something as simple as a uart requires a SCLK and a PCLK, however, most
+linux driver will not enable clocks others than the ones they explicitly
+require.
+Therefore, a clock driver 'group' was created as renesas,rzn1-clock-group that
+allows to specify one single clock per driver, while still preparing and
+claiming other 'associated' clocks.
+For example:
+		 sclk_uart0_grp: sclk_uart0_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&gsclk_uart0 &pclk_uart0>;
+		 };
+This will group gsclk_uart0 pclk_uart0 together. The driver will transparently
+appear as gsclk_uart0, but will also enable and disable pclk_uart0 along with
+the sclk.
+This grouping is prevent having to patch multiple linux drivers to force
+enable multiple clocks.
+
+8] Clock tree inspection & tweak
+--------------------------------
+The clock tree can be monitored using debugfs (assuming your kernel has debugfs
+compiled in).
+# mount -t debugfs / /sys/kernel/debug/
+# cd /sys/kernel/debug/
+# cat clk/clk_summary
+You can then also change the clock rates, for clocks nodes that can:
+# echo div_ca7 250000000 >/sys/kernel/rzn1/clk_set_rate
diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index 925081e..b7fa2c4 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -75,6 +75,7 @@ obj-$(CONFIG_COMMON_CLK_PXA)		+= pxa/
 obj-$(CONFIG_COMMON_CLK_QCOM)		+= qcom/
 obj-$(CONFIG_ARCH_RENESAS)		+= renesas/
 obj-$(CONFIG_ARCH_ROCKCHIP)		+= rockchip/
+obj-$(CONFIG_ARCH_RZN1)			+= rzn1/
 obj-$(CONFIG_COMMON_CLK_SAMSUNG)	+= samsung/
 obj-$(CONFIG_ARCH_SIRF)			+= sirf/
 obj-$(CONFIG_ARCH_SOCFPGA)		+= socfpga/
diff --git a/drivers/clk/rzn1/Makefile b/drivers/clk/rzn1/Makefile
new file mode 100644
index 0000000..b17dc68
--- /dev/null
+++ b/drivers/clk/rzn1/Makefile
@@ -0,0 +1,7 @@
+obj-y += rzn1-clock.o
+obj-y += rzn1-clock-divider.o
+obj-y += rzn1-clock-gate.o
+obj-y += rzn1-clock-selector.o
+obj-y += rzn1-clock-bitselect.o
+obj-y += rzn1-clock-group.o
+
diff --git a/drivers/clk/rzn1/rzn1-clkctrl-tables.h b/drivers/clk/rzn1/rzn1-clkctrl-tables.h
new file mode 100644
index 0000000..f0382f1
--- /dev/null
+++ b/drivers/clk/rzn1/rzn1-clkctrl-tables.h
@@ -0,0 +1,297 @@
+/*
+ * This file was autogenerated
+ * DO NOT EDIT
+ * (C) 2015-2016 Renesas Electronics Europe, LTD
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __RZN1_CLKCTRL_TABLES_H__
+#define __RZN1_CLKCTRL_TABLES_H__
+
+#define RZN1_CLK_COUNT		129
+
+static const struct rzn1_clkdesc rzn1_clock_list[RZN1_CLK_COUNT] = {
+	[RZN1_HCLK_SDIO0_ID] =
+		_CLK("hclk_sdio0",	_BIT(3, 0), _BIT(3, 1), _BIT(3, 2), _BIT(3, 3), _BIT(4, 0), _BIT(4, 1), _BIT(4, 2)),
+	[RZN1_CLK_SDIO0_ID] =
+		_CLK("clk_sdio0",	_BIT(3, 4), {}, {}, {}, {}, {}, {}),
+	[RZN1_HCLK_USBH_ID] =
+		_CLK("hclk_usbh",	_BIT(7, 0), _BIT(7, 1), {}, _BIT(7, 2), {}, _BIT(8, 0), _BIT(8, 1)),
+	[RZN1_HCLK_USBF_ID] =
+		_CLK("hclk_usbf",	_BIT(7, 3), {}, {}, _BIT(7, 4), {}, _BIT(8, 2), _BIT(8, 3)),
+	[RZN1_HCLK_USBPM_ID] =
+		_CLK("hclk_usbpm",	_BIT(7, 5), {}, {}, {}, {}, {}, {}),
+	[RZN1_CLK_PCI_USB_ID] =
+		_CLK("clk_pci_usb",	_BIT(7, 6), {}, {}, {}, {}, {}, {}),
+	[RZN1_HCLK_CRYPTO_EIP93_ID] =
+		_CLK("hclk_crypto_eip93",	_BIT(9, 0), _BIT(9, 1), {}, _BIT(9, 2), {}, _BIT(10, 0), _BIT(10, 1)),
+	[RZN1_HCLK_CRYPTO_EIP150_ID] =
+		_CLK("hclk_crypto_eip150",	_BIT(9, 3), _BIT(9, 4), _BIT(9, 5), {}, _BIT(10, 2), {}, {}),
+	[RZN1_HCLK_MSEBI_S_ID] =
+		_CLK("hclk_msebi_s",	_BIT(11, 0), _BIT(11, 1), _BIT(11, 2), _BIT(11, 3), _BIT(12, 0), _BIT(12, 1), _BIT(12, 2)),
+	[RZN1_HCLK_MSEBI_M_ID] =
+		_CLK("hclk_msebi_m",	_BIT(11, 4), _BIT(11, 5), _BIT(11, 6), {}, _BIT(12, 3), {}, {}),
+	[RZN1_HCLK_UART0_ID] =
+		_CLK("hclk_uart0",	_BIT(13, 0), _BIT(13, 1), _BIT(13, 2), {}, {}, {}, {}),
+	[RZN1_HCLK_UART1_ID] =
+		_CLK("hclk_uart1",	_BIT(13, 3), _BIT(13, 4), _BIT(13, 5), {}, {}, {}, {}),
+	[RZN1_HCLK_UART2_ID] =
+		_CLK("hclk_uart2",	_BIT(13, 6), _BIT(13, 7), _BIT(13, 8), {}, {}, {}, {}),
+	[RZN1_HCLK_I2C0_ID] =
+		_CLK("hclk_i2c0",	_BIT(13, 9), _BIT(13, 10), _BIT(13, 11), {}, {}, {}, {}),
+	[RZN1_HCLK_I2C1_ID] =
+		_CLK("hclk_i2c1",	_BIT(13, 12), _BIT(13, 13), _BIT(13, 14), {}, {}, {}, {}),
+	[RZN1_HCLK_ADC_ID] =
+		_CLK("hclk_adc",	_BIT(13, 15), _BIT(13, 16), _BIT(13, 17), {}, {}, {}, {}),
+	[RZN1_CLK_UART0_ID] =
+		_CLK("clk_uart0",	_BIT(13, 18), _BIT(13, 19), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBUART0_ID] =
+		_CLK("clk_usbuart0",	_BIT(13, 20), _BIT(13, 21), {}, {}, {}, {}, {}),
+	[RZN1_CLK_UART1_ID] =
+		_CLK("clk_uart1",	_BIT(13, 22), _BIT(13, 23), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBUART1_ID] =
+		_CLK("clk_usbuart1",	_BIT(13, 24), _BIT(13, 25), {}, {}, {}, {}, {}),
+	[RZN1_CLK_UART2_ID] =
+		_CLK("clk_uart2",	_BIT(13, 26), _BIT(13, 27), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBUART2_ID] =
+		_CLK("clk_usbuart2",	_BIT(13, 28), _BIT(13, 29), {}, {}, {}, {}, {}),
+	[RZN1_CLK_I2C0_ID] =
+		_CLK("clk_i2c0",	_BIT(15, 6), _BIT(15, 7), {}, {}, {}, {}, {}),
+	[RZN1_CLK_I2C1_ID] =
+		_CLK("clk_i2c1",	_BIT(15, 8), _BIT(15, 9), {}, {}, {}, {}, {}),
+	[RZN1_CLK_ADC_ID] =
+		_CLK("clk_adc",		_BIT(15, 10), _BIT(15, 11), {}, {}, {}, {}, {}),
+	[RZN1_HCLK_SGPIO0_ID] =
+		_CLK("hclk_sgpio0",	_BIT(15, 0), _BIT(15, 1), _BIT(15, 2), {}, {}, {}, {}),
+	[RZN1_HCLK_SGPIO1_ID] =
+		_CLK("hclk_sgpio1",	_BIT(15, 3), _BIT(15, 4), _BIT(15, 5), {}, {}, {}, {}),
+	[RZN1_HCLK_PWMPTO_ID] =
+		_CLK("hclk_pwmpto",	_BIT(15, 12), _BIT(15, 13), _BIT(15, 14), {}, {}, {}, {}),
+	[RZN1_HCLK_DELTASIGMA_ID] =
+		_CLK("hclk_deltasigma",	_BIT(15, 15), _BIT(15, 16), _BIT(15, 17), {}, {}, {}, {}),
+	[RZN1_HCLK_SPI0_ID] =
+		_CLK("hclk_spi0",	_BIT(16, 0), _BIT(16, 1), _BIT(16, 2), {}, {}, {}, {}),
+	[RZN1_HCLK_SPI1_ID] =
+		_CLK("hclk_spi1",	_BIT(16, 3), _BIT(16, 4), _BIT(16, 5), {}, {}, {}, {}),
+	[RZN1_HCLK_SPI2_ID] =
+		_CLK("hclk_spi2",	_BIT(16, 6), _BIT(16, 7), _BIT(16, 8), {}, {}, {}, {}),
+	[RZN1_HCLK_SPI3_ID] =
+		_CLK("hclk_spi3",	_BIT(16, 9), _BIT(16, 10), _BIT(16, 11), {}, {}, {}, {}),
+	[RZN1_HCLK_SPI4_ID] =
+		_CLK("hclk_spi4",	_BIT(16, 12), _BIT(16, 13), _BIT(16, 14), {}, {}, {}, {}),
+	[RZN1_HCLK_SPI5_ID] =
+		_CLK("hclk_spi5",	_BIT(16, 15), _BIT(16, 16), _BIT(16, 17), {}, {}, {}, {}),
+	[RZN1_HCLK_GPIO0_ID] =
+		_CLK("hclk_gpio0",	_BIT(16, 18), _BIT(16, 19), _BIT(16, 20), {}, {}, {}, {}),
+	[RZN1_HCLK_GPIO1_ID] =
+		_CLK("hclk_gpio1",	_BIT(16, 21), _BIT(16, 22), _BIT(16, 23), {}, {}, {}, {}),
+	[RZN1_HCLK_UART3_ID] =
+		_CLK("hclk_uart3",	_BIT(16, 24), _BIT(16, 25), _BIT(16, 26), {}, {}, {}, {}),
+	[RZN1_HCLK_UART4_ID] =
+		_CLK("hclk_uart4",	_BIT(16, 27), _BIT(16, 28), _BIT(16, 29), {}, {}, {}, {}),
+	[RZN1_HCLK_UART5_ID] =
+		_CLK("hclk_uart5",	_BIT(17, 0), _BIT(17, 1), _BIT(17, 2), {}, {}, {}, {}),
+	[RZN1_HCLK_UART6_ID] =
+		_CLK("hclk_uart6",	_BIT(17, 3), _BIT(17, 4), _BIT(17, 5), {}, {}, {}, {}),
+	[RZN1_HCLK_UART7_ID] =
+		_CLK("hclk_uart7",	_BIT(17, 6), _BIT(17, 7), _BIT(17, 8), {}, {}, {}, {}),
+	[RZN1_HCLK_GPIO2_ID] =
+		_CLK("hclk_gpio2",	_BIT(17, 9), _BIT(17, 10), _BIT(17, 11), {}, {}, {}, {}),
+	[RZN1_HCLK_PG19_ID] =
+		_CLK("hclk_pg19",	_BIT(17, 12), _BIT(17, 13), _BIT(17, 14), {}, {}, {}, {}),
+	[RZN1_HCLK_PG20_ID] =
+		_CLK("hclk_pg20",	_BIT(17, 15), _BIT(17, 16), _BIT(17, 17), {}, {}, {}, {}),
+	[RZN1_HCLK_DMA0_ID] =
+		_CLK("hclk_dma0",	_BIT(19, 0), _BIT(19, 1), _BIT(19, 2), _BIT(19, 3), _BIT(22, 0), _BIT(22, 1), _BIT(22, 2)),
+	[RZN1_HCLK_DMA1_ID] =
+		_CLK("hclk_dma1",	_BIT(19, 4), _BIT(19, 5), _BIT(19, 6), _BIT(19, 7), _BIT(22, 3), _BIT(22, 4), _BIT(22, 5)),
+	[RZN1_HCLK_NAND_ID] =
+		_CLK("hclk_nand",	_BIT(20, 0), _BIT(20, 1), _BIT(20, 2), _BIT(20, 3), _BIT(23, 0), _BIT(23, 1), _BIT(23, 2)),
+	[RZN1_CLK_NAND_ID] =
+		_CLK("clk_nand",	_BIT(20, 4), _BIT(20, 5), {}, {}, {}, {}, {}),
+	[RZN1_HCLK_QSPI0_ID] =
+		_CLK("hclk_qspi0",	_BIT(21, 0), _BIT(21, 1), _BIT(21, 2), _BIT(21, 3), _BIT(24, 0), _BIT(24, 1), _BIT(24, 2)),
+	[RZN1_CLK_QSPI0_ID] =
+		_CLK("clk_qspi0",	_BIT(21, 4), _BIT(21, 5), {}, {}, {}, {}, {}),
+	[RZN1_HCLK_DDRC_ID] =
+		_CLK("hclk_ddrc",	_BIT(25, 0), _BIT(25, 2), {}, _BIT(25, 1), {}, _BIT(29, 0), _BIT(29, 1)),
+	[RZN1_CLK_DDRC_ID] =
+		_CLK("clk_ddrc",	_BIT(25, 3), _BIT(25, 4), {}, {}, {}, {}, {}),
+	[RZN1_CLK_RGMII_REF_ID] =
+		_CLK("clk_rgmii_ref",	_BIT(26, 0), {}, {}, {}, {}, {}, {}),
+	[RZN1_CLK_RMII_REF_ID] =
+		_CLK("clk_rmii_ref",	_BIT(26, 1), {}, {}, {}, {}, {}, {}),
+	[RZN1_CLK_MII_REF_ID] =
+		_CLK("clk_mii_ref",	_BIT(26, 2), {}, {}, {}, {}, {}, {}),
+	[RZN1_HCLK_GMAC0_ID] =
+		_CLK("hclk_gmac0",	_BIT(27, 0), _BIT(27, 1), _BIT(27, 2), _BIT(27, 3), _BIT(30, 0), _BIT(30, 1), _BIT(30, 2)),
+	[RZN1_HCLK_GMAC1_ID] =
+		_CLK("hclk_gmac1",	_BIT(28, 0), _BIT(28, 1), _BIT(28, 2), _BIT(28, 3), _BIT(31, 0), _BIT(31, 1), _BIT(31, 2)),
+	[RZN1_HCLK_ECAT125_ID] =
+		_CLK("hclk_ecat125",	_BIT(32, 0), _BIT(32, 1), {}, _BIT(32, 2), {}, _BIT(34, 0), _BIT(34, 1)),
+	[RZN1_CLK_ECAT25_ID] =
+		_CLK("clk_ecat25",	_BIT(32, 3), _BIT(32, 4), {}, {}, {}, {}, {}),
+	[RZN1_CLK_ECAT100_ID] =
+		_CLK("clk_ecat100",	_BIT(32, 5), {}, {}, {}, {}, {}, {}),
+	[RZN1_HCLK_SERCOS_ID] =
+		_CLK("hclk_sercos",	_BIT(33, 0), _BIT(33, 2), {}, _BIT(33, 1), {}, _BIT(35, 0), _BIT(35, 1)),
+	[RZN1_CLK_SERCOS50_ID] =
+		_CLK("clk_sercos50",	_BIT(33, 4), _BIT(33, 3), {}, {}, {}, {}, {}),
+	[RZN1_CLK_SERCOS100_ID] =
+		_CLK("clk_sercos100",	_BIT(33, 5), {}, {}, {}, {}, {}, {}),
+	[RZN1_HCLK_QSPI1_ID] =
+		_CLK("hclk_qspi1",	_BIT(36, 0), _BIT(36, 1), _BIT(36, 2), _BIT(36, 3), _BIT(38, 0), _BIT(38, 1), _BIT(38, 2)),
+	[RZN1_CLK_QSPI1_ID] =
+		_CLK("clk_qspi1",	_BIT(36, 4), _BIT(36, 5), {}, {}, {}, {}, {}),
+	[RZN1_HCLK_HSR_ID] =
+		_CLK("hclk_hsr",	_BIT(36, 0), _BIT(36, 2), {}, _BIT(36, 1), {}, _BIT(38, 0), _BIT(38, 1)),
+	[RZN1_CLK_HSR_DUP_ID] =
+		_CLK("clk_hsr_dup",	_BIT(36, 3), {}, {}, {}, {}, {}, {}),
+	[RZN1_CLK_HSR50_ID] =
+		_CLK("clk_hsr50",	_BIT(36, 4), _BIT(36, 5), {}, {}, {}, {}, {}),
+	[RZN1_HCLK_SDIO1_ID] =
+		_CLK("hclk_sdio1",	_BIT(50, 0), _BIT(50, 1), _BIT(50, 2), _BIT(50, 3), _BIT(51, 0), _BIT(51, 1), _BIT(51, 2)),
+	[RZN1_CLK_SDIO1_ID] =
+		_CLK("clk_sdio1",	_BIT(50, 4), {}, {}, {}, {}, {}, {}),
+	[RZN1_HCLK_PINCONFIG_ID] =
+		_CLK("hclk_pinconfig",	_BIT(58, 0), _BIT(58, 1), _BIT(58, 2), {}, _BIT(87, 0), {}, {}),
+	[RZN1_HCLK_TIMER0_ID] =
+		_CLK("hclk_timer0",	_BIT(58, 3), _BIT(58, 4), _BIT(58, 5), {}, _BIT(87, 1), {}, {}),
+	[RZN1_HCLK_TIMER1_ID] =
+		_CLK("hclk_timer1",	_BIT(58, 6), _BIT(58, 7), _BIT(58, 8), {}, _BIT(87, 2), {}, {}),
+	[RZN1_CLK_25MHZ_PG4_ID] =
+		_CLK("clk_25mhz_pg4",	_BIT(58, 9), _BIT(58, 10), _BIT(58, 11), {}, _BIT(87, 3), {}, {}),
+	[RZN1_CLK_25MHZ_PG5_ID] =
+		_CLK("clk_25mhz_pg5",	_BIT(58, 12), _BIT(58, 13), _BIT(58, 14), {}, _BIT(87, 4), {}, {}),
+	[RZN1_CLK_25MHZ_PG6_ID] =
+		_CLK("clk_25mhz_pg6",	_BIT(58, 15), _BIT(58, 16), _BIT(58, 17), {}, _BIT(87, 5), {}, {}),
+	[RZN1_CLK_25MHZ_PG7_ID] =
+		_CLK("clk_25mhz_pg7",	_BIT(58, 18), _BIT(58, 19), _BIT(58, 20), {}, _BIT(87, 6), {}, {}),
+	[RZN1_CLK_25MHZ_PG8_ID] =
+		_CLK("clk_25mhz_pg8",	_BIT(58, 21), _BIT(58, 22), _BIT(58, 23), {}, _BIT(87, 7), {}, {}),
+	[RZN1_CLK_UART3_ID] =
+		_CLK("clk_uart3",	_BIT(59, 0), _BIT(59, 1), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBUART3_ID] =
+		_CLK("clk_usbuart3",	_BIT(59, 2), _BIT(59, 3), {}, {}, {}, {}, {}),
+	[RZN1_CLK_UART4_ID] =
+		_CLK("clk_uart4",	_BIT(59, 4), _BIT(59, 5), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBUART4_ID] =
+		_CLK("clk_usbuart4",	_BIT(59, 6), _BIT(59, 7), {}, {}, {}, {}, {}),
+	[RZN1_CLK_UART5_ID] =
+		_CLK("clk_uart5",	_BIT(59, 8), _BIT(59, 9), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBUART5_ID] =
+		_CLK("clk_usbuart5",	_BIT(59, 10), _BIT(59, 11), {}, {}, {}, {}, {}),
+	[RZN1_CLK_UART6_ID] =
+		_CLK("clk_uart6",	_BIT(59, 12), _BIT(59, 13), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBUART6_ID] =
+		_CLK("clk_usbuart6",	_BIT(59, 14), _BIT(59, 15), {}, {}, {}, {}, {}),
+	[RZN1_CLK_UART7_ID] =
+		_CLK("clk_uart7",	_BIT(59, 16), _BIT(59, 17), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBUART7_ID] =
+		_CLK("clk_usbuart7",	_BIT(59, 18), _BIT(59, 19), {}, {}, {}, {}, {}),
+	[RZN1_CLK_NOUSBP2_PG6_ID] =
+		_CLK("clk_nousbp2_pg6",	_BIT(59, 20), _BIT(59, 21), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBP2_PG6_ID] =
+		_CLK("clk_usbp2_pg6",	_BIT(59, 22), _BIT(59, 23), {}, {}, {}, {}, {}),
+	[RZN1_HCLK_CAN1_ID] =
+		_CLK("hclk_can1",	_BIT(60, 6), _BIT(60, 7), _BIT(60, 8), {}, _BIT(88, 2), {}, {}),
+	[RZN1_CLK_48MHZ_PG4_ID] =
+		_CLK("clk_48mhz_pg4",	_BIT(60, 9), _BIT(60, 10), _BIT(60, 11), {}, _BIT(88, 3), {}, {}),
+	[RZN1_CLK_48MHZ_PG_F_ID] =
+		_CLK("clk_48mhz_pg_f",	_BIT(60, 12), _BIT(60, 13), {}, _BIT(60, 14), {}, _BIT(88, 4), _BIT(88, 5)),
+	[RZN1_HCLK_RSV_ID] =
+		_CLK("hclk_rsv",	_BIT(60, 0), _BIT(60, 1), _BIT(60, 2), {}, _BIT(88, 0), {}, {}),
+	[RZN1_HCLK_CAN0_ID] =
+		_CLK("hclk_can0",	_BIT(60, 3), _BIT(60, 4), _BIT(60, 5), {}, _BIT(88, 1), {}, {}),
+	[RZN1_HCLK_LCD_ID] =
+		_CLK("hclk_lcd",	_BIT(61, 0), _BIT(61, 1), _BIT(61, 2), {}, _BIT(89, 0), {}, {}),
+	[RZN1_HCLK_SEMAP_ID] =
+		_CLK("hclk_semap",	_BIT(61, 3), _BIT(61, 4), _BIT(61, 5), {}, _BIT(89, 1), {}, {}),
+	[RZN1_HCLK_PG3_ID] =
+		_CLK("hclk_pg3",	_BIT(61, 6), _BIT(61, 7), _BIT(61, 8), {}, _BIT(89, 2), {}, {}),
+	[RZN1_HCLK_PG4_ID] =
+		_CLK("hclk_pg4",	_BIT(61, 9), _BIT(61, 10), _BIT(61, 11), {}, _BIT(89, 3), {}, {}),
+	[RZN1_HCLK_PG_I_ID] =
+		_CLK("hclk_pg_i",	_BIT(61, 12), _BIT(61, 13), {}, _BIT(61, 14), {}, _BIT(89, 4), _BIT(89, 5)),
+	[RZN1_CLK_SPI0_ID] =
+		_CLK("clk_spi0",	_BIT(63, 0), _BIT(63, 1), {}, {}, {}, {}, {}),
+	[RZN1_CLK_SPI1_ID] =
+		_CLK("clk_spi1",	_BIT(63, 2), _BIT(63, 3), {}, {}, {}, {}, {}),
+	[RZN1_CLK_SPI2_ID] =
+		_CLK("clk_spi2",	_BIT(63, 4), _BIT(63, 5), {}, {}, {}, {}, {}),
+	[RZN1_CLK_SPI3_ID] =
+		_CLK("clk_spi3",	_BIT(63, 6), _BIT(63, 7), {}, {}, {}, {}, {}),
+	[RZN1_CLK_SPI4_ID] =
+		_CLK("clk_spi4",	_BIT(65, 0), _BIT(65, 1), {}, {}, {}, {}, {}),
+	[RZN1_CLK_SPI5_ID] =
+		_CLK("clk_spi5",	_BIT(65, 2), _BIT(65, 3), {}, {}, {}, {}, {}),
+	[RZN1_CLK_P4_PG3_ID] =
+		_CLK("clk_p4_pg3",	_BIT(65, 4), _BIT(65, 5), {}, {}, {}, {}, {}),
+	[RZN1_CLK_P4_PG4_ID] =
+		_CLK("clk_p4_pg4",	_BIT(65, 6), _BIT(65, 7), {}, {}, {}, {}, {}),
+	[RZN1_CLK_SLCD_ID] =
+		_CLK("clk_slcd",	_BIT(67, 0), _BIT(67, 1), {}, {}, {}, {}, {}),
+	[RZN1_CLK_P1_PG2_ID] =
+		_CLK("clk_p1_pg2",	_BIT(67, 2), _BIT(67, 3), {}, {}, {}, {}, {}),
+	[RZN1_CLK_P1_PG3_ID] =
+		_CLK("clk_p1_pg3",	_BIT(67, 4), _BIT(67, 5), {}, {}, {}, {}, {}),
+	[RZN1_CLK_P1_PG4_ID] =
+		_CLK("clk_p1_pg4",	_BIT(67, 6), _BIT(67, 7), {}, {}, {}, {}, {}),
+	[RZN1_CLK_P6_PG1_ID] =
+		_CLK("clk_p6_pg1",	_BIT(69, 0), _BIT(69, 1), _BIT(69, 2), {}, _BIT(91, 0), {}, {}),
+	[RZN1_CLK_P6_PG2_ID] =
+		_CLK("clk_p6_pg2",	_BIT(69, 3), _BIT(69, 4), _BIT(69, 5), {}, _BIT(91, 1), {}, {}),
+	[RZN1_CLK_P6_PG3_ID] =
+		_CLK("clk_p6_pg3",	_BIT(69, 6), _BIT(69, 7), _BIT(69, 8), {}, _BIT(91, 2), {}, {}),
+	[RZN1_CLK_P6_PG4_ID] =
+		_CLK("clk_p6_pg4",	_BIT(69, 9), _BIT(69, 10), _BIT(69, 11), {}, _BIT(91, 3), {}, {}),
+	[RZN1_HCLK_SGPIO2_ID] =
+		_CLK("hclk_sgpio2",	_BIT(70, 3), _BIT(70, 4), _BIT(70, 5), {}, _BIT(90, 1), {}, {}),
+	[RZN1_HCLK_SGPIO3_ID] =
+		_CLK("hclk_sgpio3",	_BIT(70, 6), _BIT(70, 7), _BIT(70, 8), {}, _BIT(90, 2), {}, {}),
+	[RZN1_HCLK_SGPIO4_ID] =
+		_CLK("hclk_sgpio4",	_BIT(70, 9), _BIT(70, 10), _BIT(70, 11), {}, _BIT(90, 3), {}, {}),
+	[RZN1_HCLK_SWITCH_ID] =
+		_CLK("hclk_switch",	_BIT(76, 0), {}, _BIT(76, 1), {}, {}, {}, {}),
+	[RZN1_CLK_SWITCH_ID] =
+		_CLK("clk_switch",	_BIT(76, 2), _BIT(76, 3), {}, {}, {}, {}, {}),
+	[RZN1_HCLK_RTC_ID] =
+		_CLK("hclk_rtc",	_BIT(80, 0), {}, {}, {}, {}, {}, {}),
+	[RZN1_HCLK_ROM_ID] =
+		_CLK("hclk_rom",	_BIT(85, 0), _BIT(85, 1), _BIT(85, 2), {}, _BIT(92, 0), {}, {}),
+	[RZN1_CLK_CM3_ID] =
+		_CLK("clk_cm3",		_BIT(93, 0), _BIT(93, 1), {}, _BIT(93, 2), {}, _BIT(94, 0), _BIT(94, 1)),
+	[RZN1_HCLK_CM3_ID] =
+		_CLK("hclk_cm3",	_BIT(97, 0), _BIT(97, 1), _BIT(97, 2), {}, {}, {}, {}),
+	[RZN1_HCLK_SWITCH_RG_ID] =
+		_CLK("hclk_switch_rg",	_BIT(98, 0), _BIT(98, 1), _BIT(98, 2), {}, {}, {}, {}),
+	[RZN1_CLK_HW_RTOS_ID] =
+		_CLK("clk_hw_rtos",	_BIT(99, 0), _BIT(99, 1), {}, {}, {}, {}, {}),
+	[RZN1_CLK_RTOS_MDC_ID] =
+		_CLK("clk_rtos_mdc",	_BIT(99, 2), {}, {}, {}, {}, {}, {}),
+};
+
+
+#endif /* __RZN1_CLKCTRL_TABLES_H__ */
diff --git a/drivers/clk/rzn1/rzn1-clock-bitselect.c b/drivers/clk/rzn1/rzn1-clock-bitselect.c
new file mode 100644
index 0000000..60778d5
--- /dev/null
+++ b/drivers/clk/rzn1/rzn1-clock-bitselect.c
@@ -0,0 +1,285 @@
+/*
+ * Copyright (C) 2014 Renesas Electronics Europe Limited
+ *
+ * Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Clock selector driven from a register bit
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/of.h>
+
+#include "rzn1-clock.h"
+
+/*
+ * This clock provider handles the case of the RZN1 where you have peripherals
+ * that have two potential clock source and two gates, one for each of the
+ * clock source - the used clock source (for all sub clocks) is selected by a
+ * single bit.
+ * That single bit affects all sub-clocks, and therefore needs to change the
+ * active gate (and turn the others off) and force a recalculation of the rates.
+ *
+ * Therefore this file implements two clock providers, one 'bitselect' that
+ * handles the switch between both parents, and another 'dualgate'
+ * that knows which gate to poke at, depending on the parent's bit position.
+ */
+
+struct rzn1_bitselect {
+	struct clk_hw	hw;
+	u32 __iomem *reg;
+	u8 bit;			/* bit for the selector */
+	u8 gate[2][8];		/* bit index for each gate, indexed by 'bit' */
+};
+
+#define to_clk_bitselect(_hw) container_of(_hw, struct rzn1_bitselect, hw)
+
+static u8 rzn1_bitselect_get_value(struct rzn1_bitselect *set)
+{
+	return clk_readl(set->reg) & (1 << set->bit) ? 1 : 0;
+}
+
+static u8 clk_mux_get_parent(struct clk_hw *hw)
+{
+	struct rzn1_bitselect *set = to_clk_bitselect(hw);
+
+	return rzn1_bitselect_get_value(set);
+}
+
+static int clk_mux_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct rzn1_bitselect *set = to_clk_bitselect(hw);
+
+	/* a single bit in the register selects one of two parent clocks */
+	if (index)
+		clk_writel(clk_readl(set->reg) | (1 << set->bit), set->reg);
+	else
+		clk_writel(clk_readl(set->reg) & ~(1 << set->bit), set->reg);
+
+	return 0;
+}
+
+static const struct clk_ops clk_bitselect_ops = {
+	.get_parent = clk_mux_get_parent,
+	.set_parent = clk_mux_set_parent,
+};
+
+/*
+ * This parses the renesas,rzn1-gate property, which consists of a list of
+ * 'gate' numbers for when the selector bit is 'off' (0) followed by a list of
+ * gate numbers for when the selector is 'on' (1).
+ *
+ * renesas,rzn1-gates =
+ *      <RZN1_CLK_SCLK_UART0 RZN1_CLK_SCLK_UART1
+ *	RZN1_CLK_SCLK_UART2>,
+ *      <RZN1_CLK_USB_SCLK_UART0 RZN1_CLK_USB_SCLK_UART1
+ *	RZN1_CLK_USB_SCLK_UART2>;
+ */
+static int __init rzn1_read_bitselect_table(
+	struct rzn1_bitselect *sel,
+	struct device_node *node)
+{
+	u32 table_size;
+	const __be32 *tablespec;
+	int i;
+
+	tablespec = of_get_property(node, "renesas,rzn1-gates", &table_size);
+	if (!tablespec)
+		return -EINVAL;
+	table_size /= sizeof(u32);
+	if (table_size & 1) {
+		pr_err("%s: %s renesas,rzn1-gates needs an even # of gates\n",
+				__func__, node->name);
+		return -EINVAL;
+	}
+	table_size /= 2;
+	if (table_size > sizeof(sel->gate[0])) {
+		pr_err("%s: %s renesas,rzn1-gates overflow\n",
+				__func__, node->name);
+		return -EINVAL;
+	}
+	pr_devel("%s count = %d\n", __func__, table_size);
+	for (i = 0; i < table_size && i < sizeof(sel->gate[0]); i++) {
+		u32 g1, g2;
+
+		of_property_read_u32_index(node, "renesas,rzn1-gates",
+			i, &g1);
+		of_property_read_u32_index(node, "renesas,rzn1-gates",
+			table_size + i, &g2);
+		pr_devel("  [%d] = %s, %s\n", i,
+			rzn1_get_clk_desc(g1)->name,
+			rzn1_get_clk_desc(g2)->name);
+		sel->gate[0][i] = g1;
+		sel->gate[1][i] = g2;
+	}
+	return 0;
+}
+
+static void __init rzn1_clock_bitselect_init(struct device_node *node)
+{
+	struct rzn1_bitselect *sel;
+	struct clk *clk;
+	const char *clk_name = node->name;
+	const char *parent_name[2];
+	u32 reg_idx;
+	u32 bit_idx;
+	struct clk_init_data init;
+
+	of_property_read_string(node, "clock-output-names", &clk_name);
+
+	parent_name[0] = of_clk_get_parent_name(node, 0);
+	parent_name[1] = of_clk_get_parent_name(node, 1);
+
+	if (!parent_name[0] || !parent_name[1]) {
+		pr_err("%s: invalid parent clocks for %s\n",
+				__func__, node->name);
+		return;
+	}
+	if (of_property_read_u32(node, "reg", &reg_idx)) {
+		pr_err("%s: missing reg property for %s\n",
+				__func__, node->name);
+		return;
+	}
+	if (of_property_read_u32(node, "renesas,rzn1-sel-bit", &bit_idx)) {
+		pr_err("%s: missing renesas,rzn1-sel-bit property for %s\n",
+				__func__, node->name);
+		return;
+	}
+
+	/* allocate the gate */
+	sel = kzalloc(sizeof(struct rzn1_bitselect), GFP_KERNEL);
+	if (!sel) {
+		pr_err("%s: could not allocate bitselect clk\n", __func__);
+		return;
+	}
+
+	init.name = clk_name;
+	init.ops = &clk_bitselect_ops;
+	init.flags = CLK_IS_BASIC | CLK_SET_RATE_PARENT;
+	init.parent_names = parent_name;
+	init.num_parents = 2;
+
+	if (rzn1_read_bitselect_table(sel, node)) {
+		pr_err("%s: could not read renesas,rzn1-gates property\n",
+			__func__);
+		kfree(sel);
+		return;
+	}
+	/* struct clk_gate assignments */
+	sel->reg = (u32 *)(((u8 *)rzn1_sysctrl_base()) + reg_idx);
+	sel->bit = bit_idx;
+	sel->hw.init = &init;
+
+	clk = clk_register(NULL, &sel->hw);
+
+	if (!IS_ERR(clk))
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+}
+
+CLK_OF_DECLARE(rzn1_bitselect_clk,
+		"renesas,rzn1-clock-bitselect", rzn1_clock_bitselect_init);
+
+struct rzn1_dualgate {
+	struct clk_hw	hw;
+	u8 gate;
+};
+#define to_clk_dualgate(_hw) container_of(_hw, struct rzn1_dualgate, hw)
+
+
+static int clk_dualgate_setenable(struct rzn1_dualgate *gate, int enable)
+{
+	struct clk *parent = clk_get_parent(gate->hw.clk);
+	struct rzn1_bitselect *sel = to_clk_bitselect(__clk_get_hw(parent));
+	uint8_t sel_bit = rzn1_bitselect_get_value(sel);
+
+	/* we always turn off the 'other' gate, regardless */
+	rzn1_clk_set_gate(sel->gate[!sel_bit][gate->gate], 0);
+	rzn1_clk_set_gate(sel->gate[sel_bit][gate->gate], enable);
+
+	return 0;
+}
+
+static int clk_gate_enable(struct clk_hw *hw)
+{
+	struct rzn1_dualgate *gate = to_clk_dualgate(hw);
+
+	clk_dualgate_setenable(gate, 1);
+
+	return 0;
+}
+
+static void clk_gate_disable(struct clk_hw *hw)
+{
+	struct rzn1_dualgate *gate = to_clk_dualgate(hw);
+
+	clk_dualgate_setenable(gate, 0);
+}
+
+static int clk_gate_is_enabled(struct clk_hw *hw)
+{
+	struct rzn1_dualgate *gate = to_clk_dualgate(hw);
+	struct clk *parent = clk_get_parent(gate->hw.clk);
+	struct rzn1_bitselect *sel = to_clk_bitselect(__clk_get_hw(parent));
+	uint8_t sel_bit = rzn1_bitselect_get_value(sel);
+
+	return rzn1_clk_is_gate_enabled(sel->gate[sel_bit][gate->gate]);
+}
+
+static const struct clk_ops clk_dualgate_ops = {
+	.enable = clk_gate_enable,
+	.disable = clk_gate_disable,
+	.is_enabled = clk_gate_is_enabled,
+};
+
+static void __init rzn1_clock_dualgate_init(struct device_node *node)
+{
+	struct rzn1_dualgate *gate;
+	struct clk *clk;
+	const char *clk_name = node->name;
+	const char *parent_name;
+	u32 gate_idx;
+	struct clk_init_data init;
+
+	of_property_read_string(node, "clock-output-names", &clk_name);
+
+	parent_name = of_clk_get_parent_name(node, 0);
+
+	if (of_property_read_u32(node, "reg", &gate_idx)) {
+		pr_err("%s: missing gate index property for %s\n",
+				__func__, node->name);
+		return;
+	}
+
+	/* allocate the gate */
+	gate = kzalloc(sizeof(struct rzn1_dualgate), GFP_KERNEL);
+	if (!gate) {
+		pr_err("%s: could not allocate dualgate clk\n", __func__);
+		return;
+	}
+
+	init.name = clk_name;
+	init.ops = &clk_dualgate_ops;
+	init.flags = CLK_IS_BASIC | CLK_SET_RATE_PARENT;
+	init.parent_names = &parent_name;
+	init.num_parents = 1;
+
+	/* struct clk_gate assignments */
+	gate->gate = gate_idx;
+	gate->hw.init = &init;
+
+	clk = clk_register(NULL, &gate->hw);
+
+	if (!IS_ERR(clk))
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+}
+
+CLK_OF_DECLARE(rzn1_dualgate_clk,
+		"renesas,rzn1-clock-dualgate", rzn1_clock_dualgate_init);
+
diff --git a/drivers/clk/rzn1/rzn1-clock-divider.c b/drivers/clk/rzn1/rzn1-clock-divider.c
new file mode 100644
index 0000000..9b262b6
--- /dev/null
+++ b/drivers/clk/rzn1/rzn1-clock-divider.c
@@ -0,0 +1,271 @@
+/*
+ * Copyright (C) 2014 Renesas Electronics Europe Limited
+ *
+ * Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/regmap.h>
+#include <linux/of_address.h>
+
+#include "rzn1-clock.h"
+
+static uint32_t ioreg[32];
+static int ioregcnt;
+
+struct rzn1_divider {
+	struct clk_hw	hw;
+	u32 __iomem *reg;
+	u16 mask;
+	u16 flags, min, max;
+	uint8_t table_size;
+	u16 table[8];	/* we know there are no more than 8 */
+};
+
+#define to_rzn1_divider(_hw) container_of(_hw, struct rzn1_divider, hw)
+
+
+static unsigned long rzn1_divider_recalc_rate(
+	struct clk_hw *hw,
+	unsigned long parent_rate)
+{
+	struct rzn1_divider *clk = to_rzn1_divider(hw);
+	long div = readl(clk->reg) & clk->mask;
+
+	pr_devel("%s %ld/%ld (mask %x)\n", __func__,
+		parent_rate, div, clk->mask);
+	if (div < clk->min)
+		div = clk->min;
+	else if (div > clk->max)
+		div = clk->max;
+	return DIV_ROUND_UP(parent_rate, div);
+}
+
+/* Attempts to find a value that is in range of min,max,
+ * and if a table of set dividers was specified for this
+ * register, try to find the fixed divider that is the closest
+ * to the target frequency */
+static long rzn1_divider_clamp_div(
+	struct rzn1_divider *clk,
+	unsigned long rate, unsigned long prate)
+{
+	long div = DIV_ROUND_UP(prate, rate);
+	int i;
+
+	if (div <= clk->min)
+		return clk->min;
+	if (div >= clk->max)
+		return clk->max;
+
+	for (i = 0; clk->table_size && i < clk->table_size - 1; i++) {
+		if (div >= clk->table[i] && div <= clk->table[i+1]) {
+			unsigned long m = rate -
+				DIV_ROUND_UP(prate, clk->table[i]);
+			unsigned long p =
+				DIV_ROUND_UP(prate, clk->table[i + 1]) -
+				rate;
+			/* select the divider that generates
+			 * the value closest to the ideal frequency */
+			div = p >= m ? clk->table[i] : clk->table[i + 1];
+			return div;
+		}
+	}
+	return div;
+}
+
+static long rzn1_divider_round_rate(
+	struct clk_hw *hw, unsigned long rate,
+	unsigned long *prate)
+{
+	struct rzn1_divider *clk = to_rzn1_divider(hw);
+	long div = DIV_ROUND_UP(*prate, rate);
+
+	pr_devel("%s %s %ld (prate %ld) (wanted div %ld)\n", __func__,
+		__clk_get_name(hw->clk), rate, *prate, div);
+	pr_devel("   min %d (%ld) max %d (%ld)\n",
+		clk->min, DIV_ROUND_UP(*prate, clk->min),
+		clk->max, DIV_ROUND_UP(*prate, clk->max));
+
+	div = rzn1_divider_clamp_div(clk, rate, *prate);
+	pr_devel("%s %s %ld / %ld = %ld\n", __func__,
+		__clk_get_name(hw->clk),
+		*prate, div, DIV_ROUND_UP(*prate, div));
+	return DIV_ROUND_UP(*prate, div);
+}
+
+static int rzn1_divider_set_rate(
+	struct clk_hw *hw, unsigned long rate,
+	unsigned long parent_rate)
+{
+	struct rzn1_divider *clk = to_rzn1_divider(hw);
+	u32 div = DIV_ROUND_UP(parent_rate, rate);
+
+	pr_devel("%s rate %ld parent %ld div %d\n", __func__,
+		rate, parent_rate, div);
+
+	/* Need to write the bit 31 with the divider value to
+	 * latch it. Technically we should wait until it has been
+	 * cleared too.
+	 * TODO: Find wether this callback is sleepable, in case
+	 * the hardware /does/ require some sort of spinloop here. */
+	writel(div | (1 << 31), clk->reg);
+
+	return 0;
+}
+
+static const struct clk_ops rzn1_clk_divider_ops = {
+	.recalc_rate = rzn1_divider_recalc_rate,
+	.round_rate = rzn1_divider_round_rate,
+	.set_rate = rzn1_divider_set_rate,
+};
+
+/*
+ * This reads an optional table for dividers, the values have to be
+ * sorted, and have to be within min and max
+ */
+static int __init rzn1_read_divider_table(
+	struct rzn1_divider *div,
+	struct device_node *node)
+{
+	u32 table_size;
+	const __be32 *tablespec;
+	int i;
+
+	tablespec = of_get_property(node, "renesas,rzn1-div-table",
+					&table_size);
+	if (!tablespec)
+		return -1;
+	table_size /= sizeof(u32);
+	if (table_size > ARRAY_SIZE(div->table)) {
+		pr_err("%s: %s renesas,rzn1-div-table overflow\n",
+				__func__, node->name);
+		table_size = ARRAY_SIZE(div->table);
+	}
+	pr_devel("%s %s renesas,rzn1-div-table size = %d (min %d, max %d)\n",
+		__func__, node->name, table_size, div->min, div->max);
+	for (i = 0; i < table_size; i++) {
+		u32 d;
+
+		of_property_read_u32_index(node, "renesas,rzn1-div-table",
+						i, &d);
+		pr_devel("  [%d] = %d\n", i, d);
+
+		if ((div->table_size && d <= div->table[div->table_size-1]) ||
+			d < div->min || d > div->max) {
+			pr_err("%s: %s renesas,rzn1-div-table invalid: %d\n",
+					__func__, node->name, d);
+			return -EOVERFLOW;
+		}
+		div->table[div->table_size++] = d;
+	}
+	return 0;
+}
+
+static struct rzn1_divider *_register_divider(
+		struct device *dev, const char *name,
+		const char *parent_name, unsigned long flags,
+		u32 __iomem *reg, u16 mask,
+		u16 min, u16 max,
+		u8 clk_divider_flags)
+{
+	struct rzn1_divider *div;
+	struct clk *clk;
+	struct clk_init_data init;
+
+	/* allocate the divider */
+	div = kzalloc(sizeof(struct rzn1_divider), GFP_KERNEL);
+	if (!div)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	init.ops = &rzn1_clk_divider_ops;
+	init.flags = flags | CLK_IS_BASIC | CLK_SET_RATE_PARENT;
+	init.parent_names = parent_name ? &parent_name : NULL;
+	init.num_parents = parent_name ? 1 : 0;
+
+	/* struct rzn1_divider assignments */
+	div->reg = reg;
+	div->mask = mask;
+	div->flags = clk_divider_flags;
+	div->hw.init = &init;
+	div->min = min;
+	div->max = max;
+
+	/* register the clock */
+	clk = clk_register(dev, &div->hw);
+
+	if (IS_ERR(clk)) {
+		kfree(div);
+		return ERR_PTR(-ENOMEM);
+	}
+	return div;
+}
+
+
+void __init rzn1_clock_divider_init(struct device_node *node)
+{
+	struct rzn1_divider *div;
+	const char *clk_name = node->name;
+	void __iomem *reg;
+	const char *parent_name;
+	u8 clk_divider_flags = 0;
+	u32 mask = 0, div_offset = 0, min = 1, max = 1;
+
+	parent_name = of_clk_get_parent_name(node, 0);
+
+	if (of_property_read_u32(node, "renesas,rzn1-div-min", &min)) {
+		min = 1;
+		pr_err("%s: missing renesas,rzn1-div-min property for %s\n",
+			__func__, node->name);
+	}
+	if (of_property_read_u32(node, "renesas,rzn1-div-max", &max)) {
+		max = min;
+		pr_err("%s: missing renesas,rzn1-div-max property for %s\n",
+			__func__, node->name);
+	}
+
+	if (of_property_read_u32(node, "reg", &div_offset)) {
+		reg = &ioreg[ioregcnt++];
+		*((u32 *)reg) = min;
+
+		pr_debug("%s: %s MISSING REG property, faking it\n",
+			__func__, node->name);
+	} else {
+		reg = ((u8 *)rzn1_sysctrl_base()) + div_offset;
+	}
+
+	if (of_property_read_u32(node, "renesas,rzn1-bit-mask", &mask)) {
+		mask = 0xff;
+		pr_err("%s: missing bit-mask property for %s\n", __func__,
+			node->name);
+	}
+
+	if (of_property_read_bool(node, "renesas,rzn1-index-power-of-two"))
+		clk_divider_flags |= CLK_DIVIDER_POWER_OF_TWO;
+
+	pr_devel("%s %s mask %x, val %x\n", __func__,
+		node->name, mask, *((u32 *)reg));
+
+	div = _register_divider(NULL, clk_name,
+			parent_name, 0,
+			reg, mask, min, max,
+			clk_divider_flags);
+
+	if (div) {
+		if (rzn1_read_divider_table(div, node) == 0)
+			of_clk_add_provider(node, of_clk_src_simple_get,
+					div->hw.clk);
+	}
+}
+
+CLK_OF_DECLARE(rzn1_divider_clk,
+	"renesas,rzn1-clock-divider", rzn1_clock_divider_init);
+
diff --git a/drivers/clk/rzn1/rzn1-clock-gate.c b/drivers/clk/rzn1/rzn1-clock-gate.c
new file mode 100644
index 0000000..6b111a1
--- /dev/null
+++ b/drivers/clk/rzn1/rzn1-clock-gate.c
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2014 Renesas Electronics Europe Limited
+ *
+ * Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/regmap.h>
+
+#include "rzn1-clock.h"
+
+/*
+ * This implements the RZ/N1 clock gate 'driver'. We cannot use the system's
+ * clock gate framework as the gates on the RZ/N1 have a special enabling
+ * sequence, therefore we use this little proxy to call into the general
+ * clock gate API in rznr-clock.c that implements what is needed.
+ */
+struct rzn1_gate {
+	struct clk_hw	hw;
+	u32 gate_idx;
+	unsigned no_disable : 1;
+};
+
+#define to_rzn1_gate(_hw) container_of(_hw, struct rzn1_gate, hw)
+
+static int clk_gate_enable(struct clk_hw *hw)
+{
+	struct rzn1_gate *g = to_rzn1_gate(hw);
+
+	rzn1_clk_set_gate(g->gate_idx, 1);
+	return 0;
+}
+
+static void clk_gate_disable(struct clk_hw *hw)
+{
+	struct rzn1_gate *g = to_rzn1_gate(hw);
+
+	if (!g->no_disable)
+		rzn1_clk_set_gate(g->gate_idx, 0);
+	else
+		printk(KERN_INFO "%s %s: disallowed\n", __func__,
+			__clk_get_name(hw->clk));
+}
+
+static int clk_gate_is_enabled(struct clk_hw *hw)
+{
+	struct rzn1_gate *g = to_rzn1_gate(hw);
+
+	return rzn1_clk_is_gate_enabled(g->gate_idx);
+}
+
+static const struct clk_ops _clk_gate_ops = {
+	.enable = clk_gate_enable,
+	.disable = clk_gate_disable,
+	.is_enabled = clk_gate_is_enabled,
+};
+
+static void __init rzn1_clock_gate_init(struct device_node *node)
+{
+	struct clk *clk;
+	const char *clk_name = node->name;
+	const char *parent_name;
+	u32 gate_idx = 0;
+	struct rzn1_gate *g;
+	struct clk_init_data init;
+
+	of_property_read_string(node, "clock-output-names", &clk_name);
+
+	parent_name = of_clk_get_parent_name(node, 0);
+
+	/* Some clock in the clock tree do not have a declared gate register */
+	if (of_property_read_u32(node, "reg", &gate_idx))
+		return;
+
+	/* allocate the gate */
+	g = kzalloc(sizeof(struct rzn1_gate), GFP_KERNEL);
+	if (!g)
+		return;
+
+	init.name = clk_name;
+	init.ops = &_clk_gate_ops;
+	init.flags = CLK_IS_BASIC | CLK_SET_RATE_PARENT;
+	init.parent_names = parent_name ? &parent_name : NULL;
+	init.num_parents = parent_name ? 1 : 0;
+
+	/* struct clk_gate assignments */
+	g->gate_idx = gate_idx;
+	g->hw.init = &init;
+	g->no_disable = of_property_read_bool(node, "renesas,no-disable");
+
+	clk = clk_register(NULL, &g->hw);
+
+	if (!IS_ERR(clk))
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+	else
+		kfree(g);
+}
+
+
+CLK_OF_DECLARE(rzn1_gate_clk, "renesas,rzn1-clock-gate", rzn1_clock_gate_init);
+
diff --git a/drivers/clk/rzn1/rzn1-clock-group.c b/drivers/clk/rzn1/rzn1-clock-group.c
new file mode 100644
index 0000000..f2ab52f
--- /dev/null
+++ b/drivers/clk/rzn1/rzn1-clock-group.c
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2014 Renesas Electronics Europe Limited
+ *
+ * Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * This driver is needed to allow clocks to be 'grouped' together, with
+ * just one enable/disable. It is needed because the RZN1 has sometime
+ * several clocks that need to be enabled for a peripheral to work, while
+ * most of the time the drivers has no nothing of more than one clock (at
+ * best).
+ * So this driver allow the grouping of these multiple sclk, pclk and so
+ * forth into one 'umbrella' clock that will enable (and claim) all the
+ * specified parent clocks and enable/disable then all when necessary
+ */
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/regmap.h>
+#include <linux/of_address.h>
+
+#include "rzn1-clock.h"
+
+struct rzn1_group {
+	struct clk_hw	hw;
+	int	used;
+	int	nparents;
+	struct {
+		const char *name;
+		struct clk *clk;
+	} parent[0];
+};
+
+#define to_clk_group(_hw) container_of(_hw, struct rzn1_group, hw)
+
+static int clk_group_enable(struct clk_hw *hw)
+{
+	struct rzn1_group *group = to_clk_group(hw);
+	int i;
+
+	group->used = 1;
+
+	for (i = 1; i < group->nparents; i++) {
+		if (!group->parent[i].clk) {
+			group->parent[i].clk =
+				__clk_lookup(group->parent[i].name);
+			if (group->parent[i].clk)
+				clk_prepare(group->parent[i].clk);
+		}
+		if (group->parent[i].clk)
+			clk_enable(group->parent[i].clk);
+	}
+
+	return 0;
+}
+
+static void clk_group_disable(struct clk_hw *hw)
+{
+	struct rzn1_group *group = to_clk_group(hw);
+	int i;
+
+	/* Do not disable clock groups that have not been initialised. This is
+	 * because we will end up decrementing the use count for clocks that
+	 * are shared by multiple IPs */
+	if (!group->used)
+		return;
+
+	for (i = 1; i < group->nparents; i++) {
+		if (!group->parent[i].clk) {
+			group->parent[i].clk =
+				__clk_lookup(group->parent[i].name);
+			if (group->parent[i].clk)
+				clk_prepare(group->parent[i].clk);
+		}
+		/* Do not clk_disable() unless the clock has been
+		 * enabled, otherwise the clk subsystem will BUG() */
+		if (group->parent[i].clk)
+			if (__clk_get_enable_count(group->parent[i].clk) > 0)
+				clk_disable(group->parent[i].clk);
+	}
+}
+
+static int clk_group_is_enabled(struct clk_hw *hw)
+{
+	struct rzn1_group *group = to_clk_group(hw);
+	struct clk *parent = clk_get_parent(group->hw.clk);
+
+	return __clk_is_enabled(parent);
+}
+
+static const struct clk_ops clk_group_ops = {
+	.enable = clk_group_enable,
+	.disable = clk_group_disable,
+	.is_enabled = clk_group_is_enabled,
+};
+
+static void __init rzn1_clock_group_init(struct device_node *node)
+{
+	const char *clk_name = node->name;
+	struct clk *clk;
+	int nparents  = 0;
+	int i;
+	struct rzn1_group *group = NULL;
+	struct clk_init_data init;
+
+	nparents = of_count_phandle_with_args(node, "clocks", "#clock-cells");
+	pr_devel("%s %s %d parents\n", __func__, node->name, nparents);
+
+	group = kzalloc(sizeof(struct rzn1_group) +
+			(sizeof(group->parent[0]) * nparents),
+			GFP_KERNEL);
+	if (IS_ERR(group)) {
+		pr_err("%s failed to allocate %s(%d)\n", __func__,
+			node->name, nparents);
+		return;
+	}
+	for (i = 0; i < nparents; i++)
+		group->parent[i].name = of_clk_get_parent_name(node, i);
+	group->nparents = nparents;
+
+	init.name = clk_name;
+	init.ops = &clk_group_ops;
+	init.flags = CLK_IS_BASIC | CLK_SET_RATE_PARENT;
+	/* There is only own 'true' parent here, the other ones are ghosts */
+	init.parent_names = &group->parent[0].name;
+	init.num_parents = 1;
+	group->hw.init = &init;
+
+	clk = clk_register(NULL, &group->hw);
+
+	if (!IS_ERR(clk))
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+
+}
+
+CLK_OF_DECLARE(rzn1_group_clk,
+		"renesas,rzn1-clock-group", rzn1_clock_group_init);
diff --git a/drivers/clk/rzn1/rzn1-clock-selector.c b/drivers/clk/rzn1/rzn1-clock-selector.c
new file mode 100644
index 0000000..935d9034
--- /dev/null
+++ b/drivers/clk/rzn1/rzn1-clock-selector.c
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2014 Renesas Electronics Europe Limited
+ *
+ * Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/regmap.h>
+#include <linux/of_address.h>
+
+#include "rzn1-clock.h"
+
+
+static uint32_t ioreg[32];
+static int ioregcnt;
+
+static void __init rzn1_clock_selector_init(struct device_node *node)
+{
+	const char *clk_name = node->name;
+	struct clk *clk;
+	int nparents  = 0;
+	const char **parent_names;
+	void __iomem *reg = NULL;
+	u32 mask = 0;
+	u32 shift = 0;
+	int i;
+	u8 clk_mux_flags = 0;
+
+	nparents = of_count_phandle_with_args(node, "clocks", "#clock-cells");
+	pr_devel("%s %s %d parents\n", __func__, node->name, nparents);
+
+	parent_names = kzalloc((sizeof(char *) * nparents),
+			GFP_KERNEL);
+	if (!parent_names)
+		return;
+
+	for (i = 0; i < nparents; i++)
+		parent_names[i] = of_clk_get_parent_name(node, i);
+	/*
+	 * TODO Find clock selector register & bits.. unspecified for
+	 * ALL of them for the minute
+	 */
+	reg = of_iomap(node, 0);
+	if (!reg) {
+		reg = &ioreg[ioregcnt++];
+		pr_debug("%s: %s MISSING REG property, faking it\n", __func__,
+			node->name);
+	}
+	if (of_property_read_u32(node, "renesas,rzn1-bit-mask", &mask)) {
+		mask = 0xf;
+		pr_debug("%s: missing bit-mask property for %s\n",
+			__func__, node->name);
+	}
+
+	if (of_property_read_u32(node, "renesas,rzn1-bit-shift", &shift)) {
+		shift = __ffs(mask);
+		mask >>= shift;
+		pr_debug("%s: bit-shift property defaults to 0x%x for %s\n",
+				__func__, shift, node->name);
+	}
+	clk = clk_register_mux_table(NULL, clk_name, parent_names, nparents,
+			0, reg, shift, mask, clk_mux_flags,
+			NULL, NULL);
+	if (!IS_ERR(clk))
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+}
+
+CLK_OF_DECLARE(rzn1_selector_clk,
+		"renesas,rzn1-clock-selector", rzn1_clock_selector_init);
diff --git a/drivers/clk/rzn1/rzn1-clock.c b/drivers/clk/rzn1/rzn1-clock.c
new file mode 100644
index 0000000..296bd47
--- /dev/null
+++ b/drivers/clk/rzn1/rzn1-clock.c
@@ -0,0 +1,260 @@
+/*
+ * Copyright (C) 2014 Renesas Electronics Europe Limited
+ *
+ * Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/delay.h>
+
+#include "rzn1-clock.h"
+#include <dt-bindings/clock/rzn1-clocks.h>
+#include <dt-bindings/soc/rzn1-sysctrl.h>
+
+#define _BIT(_r, _p) { .reg = _r, .pos = _p }
+
+#define _CLK(_n, _clk, _rst, _rdy, _midle, _scon, _mirack, _mistat ) \
+	{ .name = _n, .clock = _clk, .reset = _rst, \
+		.ready = _rdy, .masteridle = _midle }
+
+#include "rzn1-clkctrl-tables.h"
+
+static rzn1_clk_hook hook[RZN1_CLK_COUNT];
+
+void rzn1_clk_set_hook(int clkdesc_id, rzn1_clk_hook clk_hook)
+{
+	BUG_ON(clkdesc_id >= RZN1_CLK_COUNT);
+	hook[clkdesc_id] = clk_hook;
+}
+
+const struct rzn1_clkdesc *rzn1_get_clk_desc(int clkdesc_id)
+{
+	static struct rzn1_clkdesc zero = _CLK("*unknown*",
+				{}, {}, {}, {}, {}, {}, {});
+
+	return clkdesc_id < RZN1_CLK_COUNT ?
+			&rzn1_clock_list[clkdesc_id] :
+			&zero;
+}
+EXPORT_SYMBOL_GPL(rzn1_get_clk_desc);
+
+static void clk_mgr_desc_set(const struct rzn1_onereg *one, int on)
+{
+	u32 *reg = ((u32 *)rzn1_sysctrl_base()) + one->reg;
+	u32 val = clk_readl(reg);
+
+	val = (val & ~(1 << one->pos)) | ((!!on) << one->pos);
+	clk_writel(val, reg);
+}
+
+void rzn1_clk_set_gate(int clkdesc_id, int on)
+{
+	const struct rzn1_clkdesc *g = rzn1_get_clk_desc(clkdesc_id);
+
+	BUG_ON(!rzn1_sysctrl_base());
+	BUG_ON(!g->clock.reg);
+
+	if (hook[clkdesc_id])
+		if (hook[clkdesc_id](clkdesc_id, RZN1_CLK_HOOK_GATE_PRE, on))
+			return;
+	clk_mgr_desc_set(&(g->clock), on);
+
+	if (hook[clkdesc_id])
+		if (hook[clkdesc_id](clkdesc_id, RZN1_CLK_HOOK_GATE_SET, on))
+			return;
+
+	/* If the peripheral is memory mapped (i.e. an AXI slave), there is an
+	 * associated SLVRDY bit in the System Controller that needs to be set
+	 * so that the FlexWAY bus fabric passes on the read/write requests.
+	 */
+	if (g->ready.reg)
+		clk_mgr_desc_set(&(g->ready), on);
+
+	/* Clear 'Master Idle Request' bit */
+	if (g->masteridle.reg)
+		clk_mgr_desc_set(&(g->masteridle), !on);
+
+	if (hook[clkdesc_id])
+		hook[clkdesc_id](clkdesc_id, RZN1_CLK_HOOK_GATE_POST, on);
+
+	/* Note: We don't wait for FlexWAY Socket Connection signal */
+}
+EXPORT_SYMBOL_GPL(rzn1_clk_set_gate);
+
+int rzn1_clk_is_gate_enabled(int clkdesc_id)
+{
+	const struct rzn1_clkdesc *g = rzn1_get_clk_desc(clkdesc_id);
+	u32 *reg;
+
+	BUG_ON(!rzn1_sysctrl_base());
+	BUG_ON(!g->clock.reg);
+
+	reg = ((u32 *)rzn1_sysctrl_base()) + g->clock.reg;
+	return !!(clk_readl(reg) & (1 << g->clock.pos));
+}
+EXPORT_SYMBOL_GPL(rzn1_clk_is_gate_enabled);
+
+
+static ssize_t sys_clk_set_rate_show(
+	struct kobject *kobj,
+	struct kobj_attribute *attr,
+	char *buf)
+{
+	strcpy(buf, "Usage: echo <clock name> <rate in hz> >clk_set_rate\n");
+	return strlen(buf);
+}
+
+static ssize_t sys_clk_set_rate_store(
+	struct kobject *kobj,
+	struct kobj_attribute *attr,
+	const char *buf, size_t count)
+{
+	char copy[count + 1];
+	char *p = copy;
+	const char *trate;
+	const char *name;
+	long rate;
+	struct clk *clk;
+
+	/* the 'buf' is const, so we can't strsep into it */
+	strncpy(copy, buf, sizeof(copy));
+	name = strsep(&p, " ");
+	if (name)
+		trate = strsep(&p, " ");
+	if (!name || !trate)
+		return count;
+	pr_devel("%s clock:%s rate:%s\n", __func__, name, trate);
+	if (kstrtol(trate, 10, &rate) != 0) {
+		pr_err("%s %s, invalid rate %s\n", __func__, name, trate);
+		return count;
+	}
+	pr_devel("%s %s requested rate %ld\n", __func__, name, rate);
+
+	clk = __clk_lookup(name);
+	if (IS_ERR(clk)) {
+		pr_err("%s %s: clock not found\n", __func__, name);
+		return -EINVAL;
+	}
+	pr_devel("%s clk %s found\n", __func__, name);
+	pr_devel("%s %s current rate %lu\n", __func__, name,
+		clk_get_rate(clk));
+	if (rate > 0) {
+		if (clk_set_rate(clk, rate)) {
+			pr_err("%s %s FAILED\n", __func__, name);
+		} else {
+			pr_info("%s %s set to %lu\n", __func__, name,
+				clk_get_rate(clk));
+		}
+	}
+	return count;
+}
+
+static struct kobj_attribute clk_set_rate_attribute =
+	__ATTR(clk_set_rate, 0644,
+	       sys_clk_set_rate_show, sys_clk_set_rate_store);
+
+static struct attribute *attrs[] = {
+	&clk_set_rate_attribute.attr,
+	NULL,
+};
+
+static struct attribute_group attr_group = {
+	.attrs = attrs,
+};
+
+static struct kobject *grp_kobj;
+static int __init rzn1_clock_sys_init(void)
+{
+	int retval;
+
+	grp_kobj = kobject_create_and_add("rzn1", kernel_kobj);
+	if (!grp_kobj)
+		return -ENOMEM;
+	retval = sysfs_create_group(grp_kobj, &attr_group);
+	if (retval)
+		kobject_put(grp_kobj);
+	return retval;
+}
+postcore_initcall(rzn1_clock_sys_init);
+
+#define USBFUNC_EPCTR		(RZN1_USB_DEV_BASE + 0x1000 + 0x10)
+
+static int rzn1_usb_clock_hook(int clkdesc_id, int operation, u32 value)
+{
+	u32 val, h2mode = 0;
+	struct device_node *np;
+	void * epctr = NULL;
+
+	if (operation != RZN1_CLK_HOOK_GATE_POST || value != 1)
+		return 0;
+
+	np = of_find_node_by_path("/chosen");
+	if (np && of_property_read_bool(np, "rzn1,h2mode"))
+		h2mode = (1 << RZN1_SYSCTRL_REG_CFG_USB_H2MODE);
+
+	/* If the PLL is already started, we don't need to do it again anyway
+	 * and if the USB configuration is already in the right mode, we don't
+	 * need to configure that either */
+	val = rzn1_sysctrl_readl(RZN1_SYSCTRL_REG_CFG_USB);
+	if (!(val & (1 << RZN1_SYSCTRL_REG_CFG_USB_DIRPD)) &&
+		(val & (1 << RZN1_SYSCTRL_REG_CFG_USB_H2MODE)) == h2mode &&
+		rzn1_sysctrl_readl(RZN1_SYSCTRL_REG_USBSTAT) &
+			(1 << RZN1_SYSCTRL_REG_USBSTAT_PLL_LOCK)) {
+		pr_info("rzn1: USB PLL already started\n");
+		return 0;
+	}
+	pr_info("rzn1: USB PLL in %s mode\n", h2mode ? "Host" : "Func");
+
+	/* trick here, the usb function clocks NEEDS to have been enabled
+	 * otherwise this register is not available. That means the h2mode
+	 * still requires the usbf clocks, at least for this part (!) */
+	epctr = ioremap(USBFUNC_EPCTR, 4);
+	/* Hold USBF in reset */
+	writel(0x7, epctr);
+	udelay(500);
+
+	val &= ~(1 << RZN1_SYSCTRL_REG_CFG_USB_H2MODE);
+	val |= h2mode;
+	val |= (1 << RZN1_SYSCTRL_REG_CFG_USB_DIRPD);
+	val |= (1 << RZN1_SYSCTRL_REG_CFG_USB_FRCLK48MOD);
+	rzn1_sysctrl_writel(val, RZN1_SYSCTRL_REG_CFG_USB);
+
+	udelay(500);
+
+	/* Power up USB PLL */
+	val = rzn1_sysctrl_readl(RZN1_SYSCTRL_REG_CFG_USB);
+	val &= ~(1 << RZN1_SYSCTRL_REG_CFG_USB_DIRPD);
+	rzn1_sysctrl_writel(val, RZN1_SYSCTRL_REG_CFG_USB);
+
+	mdelay(1);
+	/* Release USBF and HOST resets */
+	writel(0, epctr);
+	iounmap(epctr);
+
+	/* Wait for USB PLL lock */
+	do {
+		val = rzn1_sysctrl_readl(RZN1_SYSCTRL_REG_USBSTAT);
+	} while (!(val & (1 << RZN1_SYSCTRL_REG_USBSTAT_PLL_LOCK)));
+
+	return 0;
+}
+
+static void __init rzn1_clock_init(struct device_node *node)
+{
+	rzn1_sysctrl_init();
+
+	/* This hook will decide of the fate of the HOST vs
+	 * DEVICE for the usb port -- the board designer has to enable
+	 * either of the driver in the DTS, or have the bootloader set
+	 * the appropriate DT property before starting the kernel */
+	rzn1_clk_set_hook(RZN1_CLK_48MHZ_PG_F_ID, rzn1_usb_clock_hook);
+}
+
+
+CLK_OF_DECLARE(rzn1_clock, "renesas,rzn1-clock", rzn1_clock_init);
diff --git a/drivers/clk/rzn1/rzn1-clock.h b/drivers/clk/rzn1/rzn1-clock.h
new file mode 100644
index 0000000..92230e5
--- /dev/null
+++ b/drivers/clk/rzn1/rzn1-clock.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2014 Renesas Electronics Europe Limited
+ *
+ * Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __RZN1_CLOCK_H
+#define __RZN1_CLOCK_H
+
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/sysctrl-rzn1.h>
+
+/* Generic register/bit group descriptor */
+struct rzn1_onereg {
+	uint16_t reg : 7,	/* Register number (word) */
+		pos : 5,	/* Bit number */
+		size : 4;	/* Optional: size in bits */
+};
+
+struct rzn1_clkdesc {
+	const char * name;
+	struct rzn1_onereg clock, reset, ready, masteridle;
+};
+
+/*
+ * These accessors allows control of the clock gates as
+ * defined in rzn1-clocks.h
+ */
+const struct rzn1_clkdesc *rzn1_get_clk_desc(int clkdesc_id);
+void rzn1_clk_set_gate(int clkdesc_id, int on);
+int rzn1_clk_is_gate_enabled(int clkdesc_id);
+
+/*
+ * This allow setting overrride and/or supplemental functions to specific
+ * clocks; the current case is for the USB clock that needs a special PLL
+ * register to be set.
+ */
+enum {
+	RZN1_CLK_HOOK_GATE_PRE = 0,
+	RZN1_CLK_HOOK_GATE_SET,
+	RZN1_CLK_HOOK_GATE_POST,
+};
+
+typedef int (*rzn1_clk_hook)(int clkdesc_id, int operation, u32 value);
+
+void rzn1_clk_set_hook(int clkdesc_id, rzn1_clk_hook clk_hook);
+
+#endif /* __RZN1_CLOCK_H */
+
-- 
2.7.4

