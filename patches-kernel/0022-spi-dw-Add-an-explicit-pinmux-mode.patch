From 4e92e880d371e9525aa6d487199e389a6b4edb60 Mon Sep 17 00:00:00 2001
From: Michel Pollet <michel.pollet@bp.renesas.com>
Date: Thu, 14 Jan 2016 11:00:57 +0000
Subject: [PATCH] spi-dw: Add an explicit pinmux mode

Allows the device tree to provide a set of pins to claim only when doing
transactions.
This allows the pins to be shared with another peripherals; the user is
responsible for not trying to use both at the same time.

Signed-off-by: Michel Pollet <michel.pollet@bp.renesas.com>
---
 drivers/spi/Kconfig  |  4 ++++
 drivers/spi/spi-dw.c | 15 +++++++++++++++
 drivers/spi/spi-dw.h |  7 +++++++
 3 files changed, 26 insertions(+)

diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index b799547..46e971d 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -230,6 +230,10 @@ config SPI_DW_MMIO
 	tristate "Memory-mapped io interface driver for DW SPI core"
 	depends on SPI_DESIGNWARE
 
+config SPI_DW_MMIO_MUXED
+	bool "Allow the driver to activate a pin state per transaction"
+	depends on SPI_DW_MMIO
+
 config SPI_DLN2
        tristate "Diolan DLN-2 USB SPI adapter"
        depends on MFD_DLN2
diff --git a/drivers/spi/spi-dw.c b/drivers/spi/spi-dw.c
index 27960e4..fafab96 100644
--- a/drivers/spi/spi-dw.c
+++ b/drivers/spi/spi-dw.c
@@ -138,6 +138,11 @@ static void dw_spi_set_cs(struct spi_device *spi, bool enable)
 	struct chip_data *chip = spi_get_ctldata(spi);
 
 	/* Chip select logic is inverted from spi_set_cs() */
+#ifdef CONFIG_SPI_DW_MMIO_MUXED
+	if (dws->pinon)
+		pinctrl_select_state(dws->pinctrl,
+			enable ? NULL : dws->pinon);
+#endif
 	if (chip && chip->cs_control)
 		chip->cs_control(!enable);
 
@@ -485,6 +490,16 @@ int dw_spi_add_host(struct device *dev, struct dw_spi *dws)
 	dws->dma_addr = (dma_addr_t)(dws->paddr + DW_SPI_DR);
 	snprintf(dws->name, sizeof(dws->name), "dw_spi%d", dws->bus_num);
 
+#ifdef CONFIG_SPI_DW_MMIO_MUXED
+	dws->pinctrl = devm_pinctrl_get(dev);
+	if (!IS_ERR(dws->pinctrl)) {
+		dws->pinon = pinctrl_lookup_state(dws->pinctrl, "active");
+		if (IS_ERR(dws->pinon)) {
+			dev_warn(dev, "Invalid 'active' pinmux configuration\n");
+			dws->pinon = NULL;
+		}
+	}
+#endif
 	ret = request_irq(dws->irq, dw_spi_irq, IRQF_SHARED, dws->name, master);
 	if (ret < 0) {
 		dev_err(dev, "can not get IRQ\n");
diff --git a/drivers/spi/spi-dw.h b/drivers/spi/spi-dw.h
index ed6644a..c6808e4 100644
--- a/drivers/spi/spi-dw.h
+++ b/drivers/spi/spi-dw.h
@@ -4,6 +4,9 @@
 #include <linux/io.h>
 #include <linux/scatterlist.h>
 #include <linux/gpio.h>
+#ifdef CONFIG_SPI_DW_MMIO_MUXED
+#include <linux/pinctrl/consumer.h>
+#endif
 
 /* Register offsets */
 #define DW_SPI_CTRL0			0x00
@@ -140,6 +143,10 @@ struct dw_spi {
 #ifdef CONFIG_DEBUG_FS
 	struct dentry *debugfs;
 #endif
+#ifdef CONFIG_SPI_DW_MMIO_MUXED
+	struct pinctrl 		*pinctrl;
+	struct pinctrl_state 	*pinon;
+#endif
 };
 
 static inline u32 dw_readl(struct dw_spi *dws, u32 offset)
-- 
2.7.4

