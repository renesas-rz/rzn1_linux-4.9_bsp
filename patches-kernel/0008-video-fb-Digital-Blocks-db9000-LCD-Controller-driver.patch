From 312eccf8ef5921151a0a84cc87e19fbad41dc233 Mon Sep 17 00:00:00 2001
From: Phil Edworthy <phil.edworthy@renesas.com>
Date: Wed, 19 Aug 2015 09:41:22 +0100
Subject: [PATCH] video: fb: Digital Blocks db9000 LCD Controller driver

This is based on a driver that came from The ST SPear Linux repo at
http://git.stlinux.com/?p=spear/linux-2.6.git;a=tree;hb=refs/heads/next-3.5

It has had significant changes so that it use DT for configuration, along
with changes to support a special 'blinking' mode.

Signed-off-by: Phil Edworthy <phil.edworthy@renesas.com>
---
 Documentation/devicetree/bindings/fb/db9000fb.txt  |   59 +
 .../devicetree/bindings/vendor-prefixes.txt        |    1 +
 drivers/video/backlight/Kconfig                    |   12 +
 drivers/video/fbdev/Kconfig                        |   27 +
 drivers/video/fbdev/Makefile                       |    1 +
 drivers/video/fbdev/db9000fb.c                     | 1667 ++++++++++++++++++++
 drivers/video/fbdev/db9000fb.h                     |  234 +++
 7 files changed, 2001 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/fb/db9000fb.txt
 create mode 100644 drivers/video/fbdev/db9000fb.c
 create mode 100644 drivers/video/fbdev/db9000fb.h

diff --git a/Documentation/devicetree/bindings/fb/db9000fb.txt b/Documentation/devicetree/bindings/fb/db9000fb.txt
new file mode 100644
index 0000000..75f0b39
--- /dev/null
+++ b/Documentation/devicetree/bindings/fb/db9000fb.txt
@@ -0,0 +1,59 @@
+* Digital Blocks DB9000 LCD Controller
+
+Required properties:
+- compatible: Should be "digitalblocks,db9000-clcd".
+- reg: Address and length of the register set for lcdif
+- interrupts: Should contain lcdif interrupts
+- display : phandle to display node (see below for details)
+- clocks: Clock phandles to the pixel and bus (ahb) clocks.
+
+Optional properties:
+- backlight-pwm-clock : If using the DB9000 PWM output for a backlight, this
+  specifies the PWM output clock required.
+- blink-period-ms : If built with CONFIG_FB_DB9000_BLINK, this specifies the
+  blink period in ms, see the config menu.
+- bus-width : The width of the interface to the LCD panel that is actually
+  used. This is only needed if the bits-per-pixel property is set to 16 or
+  less, but the board connects to a 24-bit panel. In which case, the controller
+  will shift the 16-bit data to the most significant bits of the panel. If the
+  buffer is less than 16bpp, the controller will use a palette to effectively
+  generate 16bpp data for the panel.
+
+* display node
+
+Required properties:
+- bits-per-pixel : <1>, <2>, <4>, <8> for paletted RGB565, <16> for RGB565,
+  <24> for packed RGB888, <32> for RGB888.
+
+Required sub-node:
+- display-timings : Refer to binding doc display-timing.txt for details.
+
+Examples:
+
+fb0: fb@RZN1_LCD_BASE {
+	compatible = "digitalblocks,db9000-clcd";
+	interrupts = <GIC_SPI RZN1_IRQ_LCD IRQ_TYPE_LEVEL_HIGH>;
+	reg = <RZN1_LCD_BASE RZN1_LCD_SIZE>;
+	clock-names = "pclk", "ahb";
+	clocks = <&clk_slcd>, <&clk_ahb_lcd>;
+	status = "okay";
+
+	bits-per-pixel = <32>;
+	display-timings {
+		native-mode = <&timing0>;
+		timing0: timing0 {
+			clock-frequency = <8000000>;
+			hactive = <320>;
+			vactive = <240>;
+			hback-porch = <68>;
+			hfront-porch = <20>;
+			vback-porch = <18>;
+			vfront-porch = <4>;
+			hsync-len = <2>;
+			vsync-len = <2>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			de-active = <1>;
+		};
+	};
+};
diff --git a/Documentation/devicetree/bindings/vendor-prefixes.txt b/Documentation/devicetree/bindings/vendor-prefixes.txt
index f0a48ea..7da83d9 100644
--- a/Documentation/devicetree/bindings/vendor-prefixes.txt
+++ b/Documentation/devicetree/bindings/vendor-prefixes.txt
@@ -73,6 +73,7 @@ delta	Delta Electronics, Inc.
 denx	Denx Software Engineering
 digi	Digi International Inc.
 digilent	Diglent, Inc.
+digitalblocks	Digital Blocks, Inc.
 dlg	Dialog Semiconductor
 dlink	D-Link Corporation
 dmo	Data Modul AG
diff --git a/drivers/video/backlight/Kconfig b/drivers/video/backlight/Kconfig
index 5ffa4b4..6cacf7b 100644
--- a/drivers/video/backlight/Kconfig
+++ b/drivers/video/backlight/Kconfig
@@ -179,6 +179,18 @@ config BACKLIGHT_ATMEL_LCDC
 	  If in doubt, it's safe to enable this option; it doesn't kick
 	  in unless the board's description says it's wired that way.
 
+config BACKLIGHT_DB9000_LCD
+	bool "Digital Block DB9000 LCDC Contrast-as-Backlight control"
+	depends on FB_DB9000
+	help
+	  This provides a backlight control internal to the DB9000 LCDC
+	  driver.  If the LCD "contrast control" on your board is wired
+	  so it controls the backlight brightness, select this option to
+	  export this as a PWM-based backlight control.
+
+	  If in doubt, it's safe to enable this option; it doesn't kick
+	  in unless the board's description says it's wired that way.
+
 config BACKLIGHT_EP93XX
 	tristate "Cirrus EP93xx Backlight Driver"
 	depends on FB_EP93XX
diff --git a/drivers/video/fbdev/Kconfig b/drivers/video/fbdev/Kconfig
index 5d3b0db..61b6926 100644
--- a/drivers/video/fbdev/Kconfig
+++ b/drivers/video/fbdev/Kconfig
@@ -2389,6 +2389,33 @@ config FB_AUO_K1901
 	  This controller can drive Sipix epaper displays and supports
 	  concurrent updates, making higher frames per second possible.
 
+config FB_DB9000
+	tristate "DB9000 LCD framebuffer support"
+	depends on FB
+	select FB_SYS_FILLRECT
+	select FB_SYS_COPYAREA
+	select FB_SYS_IMAGEBLIT
+	select FB_MODE_HELPERS if OF
+	select VIDEOMODE_HELPERS if OF
+	help
+	  Framebuffer support for Digital Blocks DB9000.
+
+config FB_DB9000_BLINK
+	bool "DB9000 LCD auto-blink support"
+	depends on FB_DB9000
+	help
+	  If the LCD Controller IP supports auto-blinking, you need
+	  to enable this option as the backlight PWM is controlled by different
+	  registers.
+
+	  To enable blinking, the bits-per-pixel dtb property is set to 24 and
+	  the blink-period-ms property specifies the blink period.
+
+	  When blinking is enabled, the Controller will automatically replace
+	  certain red and green colors with black. The framebuffer is packed
+	  24bpp, the upper two bits control the blink on/off and blink speed,
+	  followed by the colors R[7:1], G[7:0], B[7:1].
+
 config FB_JZ4740
 	tristate "JZ4740 LCD framebuffer support"
 	depends on FB && MACH_JZ4740
diff --git a/drivers/video/fbdev/Makefile b/drivers/video/fbdev/Makefile
index ee8c814..6454b07 100644
--- a/drivers/video/fbdev/Makefile
+++ b/drivers/video/fbdev/Makefile
@@ -103,6 +103,7 @@ obj-$(CONFIG_FB_BROADSHEET)       += broadsheetfb.o
 obj-$(CONFIG_FB_AUO_K190X)	  += auo_k190x.o
 obj-$(CONFIG_FB_AUO_K1900)	  += auo_k1900fb.o
 obj-$(CONFIG_FB_AUO_K1901)	  += auo_k1901fb.o
+obj-$(CONFIG_FB_DB9000) 	  += db9000fb.o
 obj-$(CONFIG_FB_S1D13XXX)	  += s1d13xxxfb.o
 obj-$(CONFIG_FB_SH7760)		  += sh7760fb.o
 obj-$(CONFIG_FB_IMX)              += imxfb.o
diff --git a/drivers/video/fbdev/db9000fb.c b/drivers/video/fbdev/db9000fb.c
new file mode 100644
index 0000000..20bf7d8
--- /dev/null
+++ b/drivers/video/fbdev/db9000fb.c
@@ -0,0 +1,1667 @@
+/*
+ * linux/drivers/video/db9000fb.c
+ * -- Digital Blocks DB9000 LCD Controller Frame Buffer Device
+ * Copyright (C) 2016 Renesas Electronics Europe Ltd.
+ * Copyright (C) 2010 Digital Blocks, Inc.
+ *
+ * Based on pxafb.c and amba-clcd.c which is:
+ * Copyright (C) 1999 Eric A. Thomas.
+ * Copyright (C) 2004 Jean-Frederic Clere.
+ * Copyright (C) 2004 Ian Campbell.
+ * Copyright (C) 2004 Jeff Lackey.
+ * Based on sa1100fb.c Copyright (C) 1999 Eric A. Thomas
+ * which in turn is
+ * Based on acornfb.c Copyright (C) Russell King.
+ * Copyright (C) 2001 ARM Limited, by David A Rusling
+ * Updated to 2.5, Deep Blue Solutions Ltd.
+ *
+ * 2010-05-01: Guy Winter <gwinter@digitalblocks.com>
+ * - ported pxafb and some amba-clcd code to DB9000
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ */
+
+#include <linux/backlight.h>
+#include <linux/clk.h>
+#include <linux/completion.h>
+#include <linux/cpufreq.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/fb.h>
+#include <linux/io.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <video/display_timing.h>
+#include <video/of_display_timing.h>
+#include "db9000fb.h"
+
+#define DRIVER_NAME "clcd-db9000"
+#define DEF_BRIGHTNESS 0x80
+
+const char *mode_option;
+
+/* Bits which should not be set in machine configuration structures */
+#define CR1_INVALID_CONFIG_MASK	(~(DB9000_CR1_ENB | DB9000_CR1_LPE |\
+			DB9000_CR1_BPP(7) | DB9000_CR1_RGB | DB9000_CR1_EPO |\
+			DB9000_CR1_EBO | DB9000_CR1_DEP | DB9000_CR1_PCP |\
+			DB9000_CR1_HSP | DB9000_CR1_VSP | DB9000_CR1_OPS(7) |\
+			DB9000_CR1_FDW(3) | DB9000_CR1_LPS |\
+			DB9000_CR1_FBP | DB9000_CR1_DEE))
+
+#define DB9000_IMR_MASK_ALL (DB9000_ISR_OFUM | DB9000_ISR_OFOM |\
+			DB9000_ISR_IFUM | DB9000_ISR_IFOM | DB9000_ISR_FERM |\
+			DB9000_ISR_MBEM | DB9000_ISR_VCTM | DB9000_ISR_BAUM |\
+			DB9000_ISR_LDDM | DB9000_ISR_ABLM | DB9000_ISR_ARIM |\
+			DB9000_ISR_ARSM | DB9000_ISR_FBEM | DB9000_ISR_FNCM |\
+			DB9000_ISR_FLCM)
+
+/* These are the lcd controller states & actions for set_ctrlr_state */
+enum {
+	C_DISABLE = 0,
+	C_ENABLE,
+	C_DISABLE_CLKCHANGE,
+	C_ENABLE_CLKCHANGE,
+	C_REENABLE,
+	C_DISABLE_PM,
+	C_ENABLE_PM,
+	C_STARTUP,
+};
+
+#define LCD_PCLK_EDGE_RISE	(0 << 9)
+#define LCD_PCLK_EDGE_FALL	(1 << 9)
+
+
+#define NUM_OF_FRAMEBUFFERS	2
+#define PALETTE_SIZE		(128 * 4)
+
+
+struct db9000fb_info {
+	struct fb_info		fb;
+	struct device		*dev;
+	struct platform_device	*pdev;
+	struct clk		*clk;
+	struct clk		*bus_clk;
+	struct clk		*pixel_clk;
+
+	struct pinctrl		*pinctrl;
+	struct pinctrl_state	*pins_default;
+	struct pinctrl_state	*pins_sleep;
+	bool			clk_enabled;
+
+	atomic_t		usage;
+
+	/* raw memory addresses */
+	unsigned long		hsync_time;
+	unsigned long		cmap[16];
+/* size of the one frame buffer */
+	size_t			frame_size;
+/* virtual address of palette memory */
+	u_int			palette_size;
+	void __iomem            *mmio_base;
+
+/* Local images/copies of device registers */
+	u32			reg_cr1;
+	u32			reg_htr;
+	u32			reg_hvter;
+	u32			reg_vtr1;
+	u32			reg_vtr2;
+	u32			reg_pctr;
+	u32			reg_dbar;
+	u32			reg_dear;
+	u32			reg_pwmfr;
+	u32			reg_pwmdcr;
+
+	u32			palette[PALETTE_SIZE/4];
+
+	u32			buswidth;
+	u_char			state;
+	u_char			old_state;
+	u_char			task_state;
+	u16			db9000_rev;
+	struct mutex		ctrlr_lock;
+	wait_queue_head_t	ctrlr_wait;
+	struct work_struct	task;
+
+	/* Completion - for PAN display alignment with VSYNC/BAU event */
+	struct completion vsync_notifier;
+
+	/* ignore_cpufreq_notification is > 0 if cpu and clcd uses diff pll */
+	bool ignore_cpufreq_notification;
+
+#ifdef CONFIG_CPU_FREQ
+	struct notifier_block	freq_transition;
+	struct notifier_block	freq_policy;
+#endif
+
+#ifdef CONFIG_BACKLIGHT_DB9000_LCD
+	struct backlight_device *backlight;
+	u32			pwm_clock;
+	u8			bl_power;
+#endif
+
+	bool			use_blinking;
+};
+
+#define to_db9000fb(info)	container_of(info, struct db9000fb_info, fb)
+#define TO_INF(ptr, member)	container_of(ptr, struct db9000fb_info, member)
+
+static inline void db9000fb_backlight_power(struct db9000fb_info *fbi, int on);
+static inline void db9000fb_lcd_power(struct db9000fb_info *fbi, int on);
+static int db9000fb_activate_var(struct fb_var_screeninfo *var,
+		struct db9000fb_info *fbi);
+static void set_ctrlr_state(struct db9000fb_info *fbi, u_int state);
+
+static inline u32
+lcd_readl(struct db9000fb_info *fbi, unsigned int off)
+{
+	return readl(fbi->mmio_base + off);
+}
+
+static inline void
+lcd_writel(struct db9000fb_info *fbi, unsigned int off, u32 val)
+{
+	writel(val, fbi->mmio_base + off);
+}
+
+static inline void
+db9000fb_schedule_work(struct db9000fb_info *fbi, u_int state)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	/*
+	 * We need to handle two requests being made at the same time.
+	 * There are two important cases:
+	 * 1. When we are changing VT (C_REENABLE) while unblanking (C_ENABLE)
+	 *	We must perform the unblanking, which will do our REENABLE for
+	 *	us.
+	 * 2. When we are blanking, but immediately unblank before we have
+	 *	blanked. We do the "REENABLE" thing here as well, just to be
+	 *	sure.
+	 */
+	if (fbi->task_state == C_ENABLE && state == C_REENABLE)
+		state = (u_int) -1;
+
+	if (fbi->task_state == C_DISABLE && state == C_ENABLE)
+		state = C_REENABLE;
+
+	if (state != (u_int)-1) {
+		fbi->task_state = state;
+		schedule_work(&fbi->task);
+	}
+
+	local_irq_restore(flags);
+}
+
+static inline u_int convert_bitfield(u_int val, struct fb_bitfield *bf)
+{
+	unsigned int mask = (1 << bf->length) - 1;
+
+	return (val >> (16 - bf->length) & mask) << bf->offset;
+}
+
+static int
+db9000fb_setpalettereg(u_int regno, u_int red, u_int green, u_int blue, u_int
+		trans, struct fb_info *info)
+{
+	struct db9000fb_info *fbi = to_db9000fb(info);
+	u_int val;
+	u16 *pal = (u16 *)&fbi->palette[0];
+
+	if (regno >= fbi->palette_size)
+		return 1;
+
+	if (fbi->fb.var.grayscale) {
+		pal[regno] = ((blue >> 8) & 0x00ff);
+		return 0;
+	}
+
+	/* red and blue swapped */
+	if (fbi->reg_cr1 & DB9000_CR1_RGB) {
+		val = red;
+		red = blue;
+		blue = val;
+	}
+
+	if ((fbi->reg_cr1 & DB9000_CR1_OPS(7)) == DB9000_CR1_OPS(1)) {
+		/* RGB, 5:5:5 format */
+		val = ((red >> 1) & 0x7c00);
+		val |= ((green >> 6) & 0x03e0);
+		val |= ((blue >> 11) & 0x001f);
+	} else {
+		/* RGB, 5:6:5 format */
+		val = ((red >> 0) & 0xf800);
+		val |= ((green >> 5) & 0x07e0);
+		val |= ((blue >> 11) & 0x001f);
+	}
+	pal[regno] = val;
+
+	return 0;
+}
+
+static int
+db9000fb_setcolreg(u_int regno, u_int red, u_int green, u_int blue, u_int trans,
+		struct fb_info *info)
+{
+	struct db9000fb_info *fbi = to_db9000fb(info);
+	unsigned int val;
+	int ret = 1;
+
+	/*
+	 * If greyscale is true, then we convert the RGB value to greyscale no
+	 * matter what visual we are using.
+	 */
+	if (fbi->fb.var.grayscale)
+		red = green = blue = (19595 * red + 38470 * green +
+				7471 * blue) >> 16;
+
+	switch (fbi->fb.fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		/*
+		 * 16-bit True Colour. We encode the RGB value according to the
+		 * RGB bitfield information.
+		 */
+		if (regno < 16) {
+			u32 *pal = fbi->fb.pseudo_palette;
+
+			val = convert_bitfield(red, &fbi->fb.var.red);
+			val |= convert_bitfield(green, &fbi->fb.var.green);
+			val |= convert_bitfield(blue, &fbi->fb.var.blue);
+
+			pal[regno] = val;
+			ret = 0;
+		}
+		break;
+
+	case FB_VISUAL_PSEUDOCOLOR:
+		ret = db9000fb_setpalettereg(regno, red, green, blue, trans,
+				info);
+		break;
+	}
+
+	return ret;
+}
+
+/*
+ * db9000fb_bpp_to_cr1():
+ *	Convert a bits per pixel value to the correct bit pattern for CR1
+ */
+static int db9000fb_bpp_to_cr1(struct fb_var_screeninfo *var)
+{
+	int ret = 0;
+
+	switch (var->bits_per_pixel) {
+	case 1:
+		ret = DB9000_CR1_BPP(DB9000_CR1_BPP_1bpp);
+		break;
+	case 2:
+		ret = DB9000_CR1_BPP(DB9000_CR1_BPP_2bpp);
+		break;
+	case 4:
+		ret = DB9000_CR1_BPP(DB9000_CR1_BPP_4bpp);
+		break;
+	case 8:
+		ret = DB9000_CR1_BPP(DB9000_CR1_BPP_8bpp);
+		break;
+	case 16:
+		ret = DB9000_CR1_BPP(DB9000_CR1_BPP_16bpp);
+		break;
+	case 18:
+		ret = DB9000_CR1_BPP(DB9000_CR1_BPP_18bpp);
+		break;
+	case 24:
+	default:
+		ret = DB9000_CR1_BPP(DB9000_CR1_BPP_24bpp);
+	}
+
+	return ret;
+}
+
+static int
+db9000fb_check_var_in(struct fb_var_screeninfo *var)
+{
+	if (var->xres < 16 || var->xres > 4096 || (var->xres % 16)) {
+		pr_err("invalid xres %d\n", var->xres);
+		return -EINVAL;
+	}
+
+	switch (var->bits_per_pixel) {
+	case 1:
+	case 2:
+	case 4:
+	case 8:
+	case 16:
+	case 18:
+	case 24:
+	case 32:
+		break;
+	default:
+		pr_err("invalid bit depth %d\n", var->bits_per_pixel);
+		return -EINVAL;
+	}
+
+	if (var->hsync_len < 0 || var->hsync_len > 255) {
+		pr_err("invalid hsync_len %d\n", var->hsync_len);
+		return -EINVAL;
+	}
+	if (var->left_margin < 0 || var->left_margin > 1023) {
+		pr_err("invalid left_margin %d\n", var->left_margin);
+		return -EINVAL;
+	}
+	if (var->right_margin < 0 || var->right_margin > 1023) {
+		pr_err("invalid right_margin %d\n", var->right_margin);
+		return -EINVAL;
+	}
+	if (var->yres < 0 || var->yres > 4096) {
+		pr_err("invalid yres %d\n", var->yres);
+		return -EINVAL;
+	}
+	if (var->vsync_len < 0 || var->vsync_len > 255) {
+		pr_err("invalid vsync_len %d\n", var->vsync_len);
+		return -EINVAL;
+	}
+	if (var->upper_margin < 0 || var->upper_margin > 1023) {
+		pr_err("invalid upper_margin %d\n", var->upper_margin);
+		return -EINVAL;
+	}
+	if (var->lower_margin < 0 || var->lower_margin > 1023) {
+		pr_err("invalid lower_margin %d\n", var->lower_margin);
+		return -EINVAL;
+	}
+	if (var->pixclock <= 0) {
+		pr_err("invalid pixel clock %d\n", var->pixclock);
+		return -EINVAL;
+	}
+	return 0;
+}
+/*
+ * db9000fb_check_var():
+ *	Get the video params out of 'var'. If a value doesn't fit, round it up,
+ *	if it's too big, return -EINVAL.
+ *
+ * Round up in the following order: bits_per_pixel, xres, yres, xres_virtual,
+ * yres_virtual, xoffset, yoffset, grayscale, bitfields, horizontal timing,
+ * vertical timing.
+ */
+static int
+db9000fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	struct db9000fb_info *fbi = to_db9000fb(info);
+
+	if (db9000fb_check_var_in(var) < 0)
+		return -EINVAL;
+
+	switch (var->bits_per_pixel) {
+	case 1:
+	case 2:
+	case 4:
+	case 8:
+		var->red.offset		= var->green.offset = 0;
+		var->blue.offset	= var->transp.offset = 0;
+		var->red.length		= var->bits_per_pixel;
+		var->green.length	= var->bits_per_pixel;
+		var->blue.length	= var->bits_per_pixel;
+		var->transp.length	= 0;
+		break;
+	case 16:
+		var->red.offset		= 11;
+		var->red.length		= 5;
+		var->green.offset	= 5;
+		var->green.length	= 6;
+		var->blue.offset	= 0;
+		var->blue.length	= 5;
+		var->transp.offset	= var->transp.length = 0;
+		break;
+	case 18: /* RGB666 */
+		var->transp.offset	= var->transp.length = 0;
+		var->red.offset		= 12;
+		var->red.length		= 6;
+		var->green.offset	= 6;
+		var->green.length	= 6;
+		var->blue.offset	= 0;
+		var->blue.length	= 6;
+		break;
+	case 24: /* RGB888 */
+		if (!fbi->use_blinking) {
+			var->transp.offset	= var->transp.length = 0;
+			var->red.offset		= 16;
+			var->red.length		= 8;
+			var->green.offset	= 8;
+			var->green.length	= 8;
+			var->blue.offset	= 0;
+			var->blue.length	= 8;
+		} else {
+			/* Blinking attributes abuse the transparency field */
+			var->transp.offset	= 22;
+			var->transp.length	= 2;
+			var->red.offset		= 15;
+			var->red.length		= 7;
+			var->green.offset	= 7;
+			var->green.length	= 8;
+			var->blue.offset	= 0;
+			var->blue.length	= 7;
+		}
+		break;
+	case 32: /* RGB888 */
+		var->transp.offset	= 24;
+		var->transp.length	= 0;
+		var->red.offset		= 16;
+		var->red.length		= 8;
+		var->green.offset	= 8;
+		var->green.length	= 8;
+		var->blue.offset	= 0;
+		var->blue.length	= 8;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static inline void db9000fb_set_truecolor(u_int is_true_color)
+{
+	/* do your machine-specific setup if needed */
+}
+
+#ifdef CONFIG_BACKLIGHT_DB9000_LCD
+static int db9000_bl_update_status(struct backlight_device *bl)
+{
+	struct db9000fb_info *fbi = bl_get_data(bl);
+	int power = fbi->bl_power;
+	int brightness = bl->props.brightness;
+
+	if (bl->props.fb_blank != fbi->bl_power)
+		power =	bl->props.fb_blank;
+	else if (bl->props.power != fbi->bl_power)
+		power =	bl->props.power;
+
+	if (power == FB_BLANK_UNBLANK && brightness < 0)
+		brightness = lcd_readl(fbi, DB9000_PWMDCR);
+	else if (power != FB_BLANK_UNBLANK)
+		brightness = 0;
+
+	/* If turning off, save current brightness */
+	if (power)
+		fbi->reg_pwmdcr = lcd_readl(fbi, DB9000_PWMDCR);
+
+	lcd_writel(fbi, DB9000_PWMDCR, brightness);
+	bl->props.fb_blank = bl->props.power = fbi->bl_power = power;
+
+	return 0;
+}
+
+static int db9000_bl_get_brightness(struct backlight_device *bl)
+{
+	struct db9000fb_info *fbi = bl_get_data(bl);
+
+	return lcd_readl(fbi, DB9000_PWMDCR);
+}
+
+static const struct backlight_ops db9000_lcd_bl_ops = {
+	.update_status = db9000_bl_update_status,
+	.get_brightness	= db9000_bl_get_brightness,
+};
+
+static void init_backlight(struct db9000fb_info *fbi)
+{
+	struct backlight_device *bl;
+	struct backlight_properties props = {0, };
+
+	if (fbi->backlight)
+		return;
+
+	/* Has a PWM clock been specified? */
+	if (!fbi->pwm_clock)
+		return;
+
+	fbi->bl_power = FB_BLANK_UNBLANK;
+	props.max_brightness = 0xff;
+	props.type = BACKLIGHT_RAW;
+	bl = devm_backlight_device_register(fbi->dev, "backlight", fbi->dev,
+			fbi, &db9000_lcd_bl_ops, &props);
+
+	if (IS_ERR(bl)) {
+		dev_err(fbi->dev, "error %ld on backlight register\n",
+				PTR_ERR(bl));
+		return;
+	}
+
+	fbi->backlight = bl;
+
+	bl->props.power = FB_BLANK_UNBLANK;
+	bl->props.fb_blank = FB_BLANK_UNBLANK;
+	bl->props.brightness = db9000_bl_get_brightness(bl);
+	backlight_update_status(bl);
+}
+#endif
+
+/*
+ * db9000fb_set_par():
+ *	Set the user defined part of the display for the specified console
+ */
+static int db9000fb_set_par(struct fb_info *info)
+{
+	struct db9000fb_info *fbi = to_db9000fb(info);
+
+	fbi->fb.var.xres_virtual = fbi->fb.var.xres;
+	fbi->fb.var.yres_virtual = fbi->fb.var.yres *
+		NUM_OF_FRAMEBUFFERS;
+
+	if (fbi->fb.var.bits_per_pixel >= 16)
+		fbi->fb.fix.visual = FB_VISUAL_TRUECOLOR;
+	else
+		fbi->fb.fix.visual = FB_VISUAL_PSEUDOCOLOR;
+
+	fbi->fb.fix.line_length = (fbi->fb.var.xres_virtual *
+					fbi->fb.var.bits_per_pixel) / 8;
+	if (fbi->fb.var.bits_per_pixel >= 16)
+		fbi->palette_size = 0;
+	else
+		fbi->palette_size = 1 << fbi->fb.var.bits_per_pixel;
+
+	/* Set (any) board control register to handle new color depth */
+	db9000fb_set_truecolor(fbi->fb.fix.visual == FB_VISUAL_TRUECOLOR);
+
+	if (fbi->fb.var.bits_per_pixel >= 16) {
+		if (fbi->fb.cmap.len)
+			fb_dealloc_cmap(&fbi->fb.cmap);
+	} else {
+		fb_alloc_cmap(&fbi->fb.cmap, fbi->palette_size, 0);
+	}
+
+	db9000fb_activate_var(&fbi->fb.var, fbi);
+
+	return 0;
+}
+
+/*
+ * db9000fb_blank():
+ *	Blank the display by setting all palette values to zero. Note, the 16
+ *	bpp mode does not really use the palette, so this will not blank the
+ *	display in all modes.
+ */
+static int db9000fb_blank(int blank, struct fb_info *info)
+{
+	struct db9000fb_info *fbi = to_db9000fb(info);
+	int i;
+
+	switch (blank) {
+	case FB_BLANK_POWERDOWN:
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_NORMAL:
+		if (fbi->fb.fix.visual == FB_VISUAL_PSEUDOCOLOR) {
+			for (i = 0; i < fbi->palette_size; i++)
+				db9000fb_setpalettereg(i, 0, 0, 0, 0, info);
+		}
+
+		db9000fb_schedule_work(fbi, C_DISABLE);
+	/* TODO: if (db9000fb_blank_helper) db9000fb_blank_helper(blank); */
+		break;
+
+	case FB_BLANK_UNBLANK:
+	/* TODO: if (db9000fb_blank_helper) db9000fb_blank_helper(blank); */
+		if (fbi->fb.fix.visual == FB_VISUAL_PSEUDOCOLOR)
+			fb_set_cmap(&fbi->fb.cmap, info);
+		db9000fb_schedule_work(fbi, C_ENABLE);
+	}
+	return 0;
+}
+
+static int db9000fb_open(struct fb_info *info, int user)
+{
+	struct db9000fb_info *fbi = to_db9000fb(info);
+
+	/* Enable Controller only if its uses is zero*/
+	if (atomic_inc_return(&fbi->usage) == 1) {
+		set_ctrlr_state(fbi, C_ENABLE);
+
+#ifdef CONFIG_BACKLIGHT_DB9000_LCD
+		init_backlight(fbi);
+#endif
+	}
+	return 0;
+}
+
+static int db9000fb_release(struct fb_info *info, int user)
+{
+	struct db9000fb_info *fbi = to_db9000fb(info);
+
+	if (atomic_dec_and_test(&fbi->usage))
+		set_ctrlr_state(fbi, C_DISABLE);
+
+	return 0;
+}
+
+/* Pan the display if device supports it. */
+static int db9000fb_pan_display(struct fb_var_screeninfo *var,
+	struct fb_info *info)
+{
+	struct db9000fb_info *fbi = to_db9000fb(info);
+	u32 frame_addr;
+	u_int y_bottom = var->yoffset;
+
+	if (!(var->vmode & FB_VMODE_YWRAP))
+		y_bottom += var->yres;
+
+	BUG_ON(y_bottom > var->yres_virtual);
+
+	frame_addr = info->fix.smem_start +
+		(var->yoffset * info->fix.line_length);
+
+	/* There are some probing calls with no buffer switch */
+	if (fbi->reg_dbar != frame_addr) {
+		u32 imr;
+
+		lcd_writel(fbi, DB9000_DBAR, frame_addr);
+		lcd_writel(fbi, DB9000_DEAR, frame_addr + fbi->frame_size);
+		lcd_writel(fbi, DB9000_MRR,
+			DB9000_MRR_DEAR_MRR(frame_addr + fbi->frame_size) |
+			DB9000_MRR_MRR(DB9000_MRR_OUTST_4));
+
+		/* Enable Base Address Update interrupt */
+		imr = lcd_readl(fbi, DB9000_IMR);
+		lcd_writel(fbi, DB9000_IMR, imr | DB9000_ISR_BAU);
+		/*
+		 * Force waiting till the current buffer is completely drawn by
+		 * video controller
+		 */
+		wait_for_completion(&fbi->vsync_notifier);
+	}
+
+	return 0;
+}
+
+static struct fb_ops db9000fb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_open	= db9000fb_open,
+	.fb_release	= db9000fb_release,
+	.fb_check_var	= db9000fb_check_var,
+	.fb_set_par	= db9000fb_set_par,
+	.fb_setcolreg	= db9000fb_setcolreg,
+	.fb_pan_display = db9000fb_pan_display,
+	.fb_fillrect	= sys_fillrect,
+	.fb_copyarea	= sys_copyarea,
+	.fb_imageblit	= sys_imageblit,
+	.fb_blank	= db9000fb_blank,
+};
+
+/*
+ * Some touchscreens need hsync information from the video driver to function
+ * correctly. We export it here. Note that 'hsync_time' and the value returned
+ * from db9000fb_get_hsync_time() is the *reciprocal* of the hsync period in
+ * seconds.
+ */
+static inline void set_hsync_time(struct db9000fb_info *fbi, unsigned int pcd)
+{
+	unsigned long htime;
+
+	if ((pcd == 0) || (fbi->fb.var.hsync_len == 0)) {
+		fbi->hsync_time = 0;
+		return;
+	}
+
+	htime = clk_get_rate(fbi->clk) / (pcd * fbi->fb.var.hsync_len);
+
+	fbi->hsync_time = htime;
+}
+
+unsigned long db9000fb_get_hsync_time(struct device *dev)
+{
+	struct db9000fb_info *fbi = dev_get_drvdata(dev);
+
+	/* If display is blanked/suspended, hsync isn't active */
+	if (!fbi || (fbi->state != C_ENABLE))
+		return 0;
+
+	return fbi->hsync_time;
+}
+EXPORT_SYMBOL(db9000fb_get_hsync_time);
+
+static u32 get_pixclk(struct db9000fb_info *fbi,
+			unsigned int pixclock)
+{
+	unsigned long clk_rate;
+	unsigned long actual_rate;
+	int pcd;
+	u32 ret;
+
+	clk_rate = PICOS2KHZ(pixclock) * 1000;
+	pr_debug("Clock value is %ld", clk_rate);
+
+	/* If input pixel clock can be set to within 10% of the requested pixel
+	 * clock, use it.
+	 */
+	actual_rate = clk_round_rate(fbi->pixel_clk, clk_rate);
+	if ((clk_rate - actual_rate) < (clk_rate / 10)) {
+		clk_set_rate(fbi->pixel_clk, actual_rate);
+		clk_set_parent(fbi->clk, fbi->pixel_clk);
+		ret = DB9000_PCTR_PCI;
+	} else {
+		/* Otherwise, use the bus clock */
+		pcd = (clk_get_rate(fbi->bus_clk) / clk_rate) - 2;
+		if (pcd < 0)
+			dev_err(&fbi->pdev->dev, "Invalid pixel clock\n");
+
+		set_hsync_time(fbi, pcd);
+		clk_set_parent(fbi->clk, fbi->bus_clk);
+		ret = DB9000_PCTR_PCD(pcd);
+	}
+
+	if (fbi->pwm_clock) {
+		/* div = pclk / (256 x pwm_clock) */
+		u32 pwmfcd = clk_get_rate(fbi->clk) / 256;
+		pwmfcd /= fbi->pwm_clock;
+		fbi->reg_pwmfr = DB9000_PWMFR_PWM_FCD(pwmfcd - 1);
+	}
+
+	return ret;
+}
+
+static void setup_parallel_timing(struct db9000fb_info *fbi,
+				struct fb_var_screeninfo *var)
+{
+	fbi->reg_pctr &= ~0x7FF;
+
+	fbi->reg_pctr |= get_pixclk(fbi, var->pixclock);
+
+	fbi->reg_htr =
+	/* horizontal sync width */
+		DB9000_HTR_HSW(var->hsync_len) |
+	/* horizontal back porch */
+		DB9000_HTR_HBP(var->left_margin) |
+	/* Pixels per line */
+		DB9000_HTR_PPL((var->xres)/16) |
+	/* Horizontal Front Porch */
+		DB9000_HTR_HFP(var->right_margin);
+
+	/* Vertical and Horizontal Timing Extension write */
+	if (fbi->db9000_rev >= DB9000_REVISION_1_14) {
+		fbi->reg_hvter =
+			DB9000_HVTER_HFPE(var->right_margin) |
+			DB9000_HVTER_HBPE(var->left_margin) |
+			DB9000_HVTER_VFPE(var->lower_margin) |
+			DB9000_HVTER_VBPE(var->upper_margin);
+	}
+
+	fbi->reg_vtr1 =
+		DB9000_VTR1_VBP(var->upper_margin) |
+		DB9000_VTR1_VFP(var->lower_margin) |
+		DB9000_VTR1_VSW((var->vsync_len));
+
+	fbi->reg_vtr2 = DB9000_VTR2_LPP(var->yres);
+
+	fbi->reg_cr1 &= ~(DB9000_CR1_HSP | DB9000_CR1_VSP);
+	fbi->reg_cr1 |=
+		(var->sync & FB_SYNC_HOR_HIGH_ACT) ? 0 : DB9000_CR1_HSP;
+	fbi->reg_cr1 |=
+		(var->sync & FB_SYNC_VERT_HIGH_ACT) ? 0 : DB9000_CR1_VSP;
+	fbi->reg_dear = lcd_readl(fbi, DB9000_DBAR) + fbi->frame_size;
+}
+
+/*
+ * db9000fb_activate_var():
+ *	Configures LCD Controller based on entries in var parameter. Settings
+ *	are only written to the controller if changes were made.
+ */
+static int db9000fb_activate_var(struct fb_var_screeninfo *var,
+				struct db9000fb_info *fbi)
+{
+	if (db9000fb_check_var_in(var) < 0)
+		return -EINVAL;
+
+	if (var->xres_virtual < var->xres)
+		return -EINVAL;
+	if (var->yres_virtual < var->yres * NUM_OF_FRAMEBUFFERS)
+		return -EINVAL;
+
+	/* Update shadow copy atomically */
+	setup_parallel_timing(fbi, var);
+
+	fbi->reg_cr1 &= ~DB9000_CR1_BPP(7);
+	fbi->reg_cr1 |= db9000fb_bpp_to_cr1(var);
+
+	if (var->bits_per_pixel == 24)
+		fbi->reg_cr1 |= DB9000_CR1_FBP;
+	else
+		fbi->reg_cr1 &= ~DB9000_CR1_FBP;
+
+	/*
+	 * Normally, the controller simply outputs pixels straight from the
+	 * buffer to the panel. Buffers less than 16bpp are effecively treated
+	 * as 16bpp due to the palette. If we are connected to a panel with a
+	 * 24-bit interface, we need to shift the data to the msbits.
+	 */
+	if (var->bits_per_pixel <= 16 && fbi->buswidth == 24)
+		fbi->reg_cr1 |= DB9000_CR1_OPS(2);
+	else
+		fbi->reg_cr1 &= ~DB9000_CR1_OPS(2);
+
+	/*
+	 * Only update the registers if the controller is enabled and something
+	 * has changed.
+	 * DBAR is not checked here, it is adviced to be updated on BAU event
+	 */
+	if ((lcd_readl(fbi, DB9000_CR1) != fbi->reg_cr1) ||
+		(lcd_readl(fbi, DB9000_HTR) != fbi->reg_htr) ||
+		(lcd_readl(fbi, DB9000_VTR1) != fbi->reg_vtr1) ||
+		(lcd_readl(fbi, DB9000_VTR2) != fbi->reg_vtr2) ||
+		(lcd_readl(fbi, DB9000_HVTER) != fbi->reg_hvter) ||
+		(lcd_readl(fbi, DB9000_PCTR) != fbi->reg_pctr) ||
+		(lcd_readl(fbi, DB9000_DBAR) != fbi->reg_dbar) ||
+		(lcd_readl(fbi, DB9000_DEAR) != fbi->reg_dear))
+		db9000fb_schedule_work(fbi, C_REENABLE);
+
+	return 0;
+}
+
+/*
+ * NOTE! The following functions are purely helpers for set_ctrlr_state. Do not
+ * call them directly; set_ctrlr_state does the correct serialisation to ensure
+ * that things happen in the right way 100% of time time.
+ * -- rmk
+ */
+static inline void db9000fb_backlight_power(struct db9000fb_info *fbi, int on)
+{
+	/* Has a PWM clock been specified? */
+	if (!fbi->pwm_clock)
+		return;
+
+	fbi->reg_pwmfr &= ~DB9000_PWMFR_PWM_FCE;
+
+	if (on) {
+		fbi->reg_pwmfr |= DB9000_PWMFR_PWM_FCE;
+		lcd_writel(fbi, DB9000_PWMDCR, fbi->reg_pwmdcr);
+	} else {
+		lcd_writel(fbi, DB9000_PWMDCR, 0x0);
+	}
+
+	lcd_writel(fbi, DB9000_PWMFR, fbi->reg_pwmfr);
+}
+
+static inline void db9000fb_lcd_power(struct db9000fb_info *fbi, int on)
+{
+	fbi->reg_cr1 &= ~DB9000_CR1_LPE;
+	if (on)
+		fbi->reg_cr1 |= DB9000_CR1_LPE;
+	lcd_writel(fbi, DB9000_CR1, fbi->reg_cr1);
+}
+
+static void db9000fb_setup_gpio(struct db9000fb_info *fbi, bool on)
+{
+	int ret;
+
+	if (on) {
+		if (!IS_ERR(fbi->pins_default)) {
+			ret = pinctrl_select_state(fbi->pinctrl,
+					fbi->pins_default);
+			if (ret)
+				dev_err(&fbi->pdev->dev,
+					"could not set default pins\n");
+		}
+	} else {
+		if (!IS_ERR(fbi->pins_sleep)) {
+			ret = pinctrl_select_state(fbi->pinctrl,
+					fbi->pins_sleep);
+			if (ret)
+				dev_err(&fbi->pdev->dev,
+					"could not set pins to sleep state\n");
+		}
+	}
+}
+
+static void db9000fb_enable_controller(struct db9000fb_info *fbi)
+{
+	int i;
+	u32 val;
+	u32 isr;
+
+	pr_debug("db9000fb: Enabling LCD controller\n");
+	pr_debug("reg_cr1: 0x%08x\n", (unsigned int) fbi->reg_cr1);
+	pr_debug("reg_htr : 0x%08x\n", (unsigned int) fbi->reg_htr);
+	pr_debug("reg_vtr1: 0x%08x\n", (unsigned int) fbi->reg_vtr1);
+	pr_debug("reg_vtr2: 0x%08x\n", (unsigned int) fbi->reg_vtr2);
+	pr_debug("reg_pctr: 0x%08x\n", (unsigned int) fbi->reg_pctr);
+
+	/* enable LCD controller clock */
+	if (!fbi->clk_enabled) {
+		fbi->clk_enabled = true;
+		clk_prepare_enable(fbi->clk);
+	}
+
+	/* Write into the palette memory */
+	if (fbi->palette_size > 0) {
+		for (i = 0; i < (fbi->palette_size/2) ; ++i) {
+			val = fbi->palette[i];
+			lcd_writel(fbi, (DB9000_PALT + i*4), val);
+		}
+	}
+
+	lcd_writel(fbi, DB9000_HTR, fbi->reg_htr);
+	lcd_writel(fbi, DB9000_VTR1, fbi->reg_vtr1);
+	lcd_writel(fbi, DB9000_VTR2, fbi->reg_vtr2);
+	lcd_writel(fbi, DB9000_HVTER, fbi->reg_hvter);
+	lcd_writel(fbi, DB9000_PCTR, fbi->reg_pctr | DB9000_PCTR_PCR);
+
+	fbi->reg_dbar = fbi->fb.fix.smem_start;
+	fbi->reg_dear = fbi->reg_dbar + fbi->frame_size;
+
+	lcd_writel(fbi, DB9000_DBAR, fbi->reg_dbar);
+	lcd_writel(fbi, DB9000_DEAR, fbi->reg_dear);
+
+	/* configure MRR to 4 outstanding requests */
+	lcd_writel(fbi, DB9000_MRR,
+		DB9000_MRR_DEAR_MRR(fbi->reg_dear) |
+		DB9000_MRR_MRR(DB9000_MRR_OUTST_4));
+
+	/* enable BAU event for IRQ */
+	isr = lcd_readl(fbi, DB9000_ISR);
+	lcd_writel(fbi, DB9000_ISR, isr | DB9000_ISR_BAU);
+	lcd_writel(fbi, DB9000_IMR, DB9000_ISR_BAU);
+
+	lcd_writel(fbi, DB9000_CR1,
+		fbi->reg_cr1 | DB9000_CR1_ENB | DB9000_CR1_DEE);
+}
+
+static void db9000fb_disable_controller(struct db9000fb_info *fbi)
+{
+	u32 cr1 = lcd_readl(fbi, DB9000_CR1) & ~DB9000_CR1_ENB;
+
+	lcd_writel(fbi, DB9000_CR1, cr1);
+	msleep(100);
+
+	if (fbi->clk_enabled) {
+		fbi->clk_enabled = false;
+		clk_disable_unprepare(fbi->clk);
+	}
+}
+
+/* db9000fb_handle_irq: Handle 'LCD DONE' interrupts. */
+static irqreturn_t db9000fb_handle_irq(int irq, void *dev_id)
+{
+	struct db9000fb_info *fbi = dev_id;
+	u32 isr = lcd_readl(fbi, DB9000_ISR);
+	u32 dbar;
+
+	if (isr & DB9000_ISR_BAU) {
+		u32 imr;
+
+		/* DMA Base Address Register Update */
+		dbar = lcd_readl(fbi, DB9000_DBAR);
+		if (dbar != fbi->reg_dbar) {
+			fbi->reg_dbar = dbar;
+			fbi->reg_dear = dbar + fbi->frame_size;
+			complete(&fbi->vsync_notifier);
+		}
+
+		/* Disable Base Address Update interrupt */
+		imr = lcd_readl(fbi, DB9000_IMR);
+		lcd_writel(fbi, DB9000_IMR, imr & ~DB9000_ISR_BAU);
+	}
+
+	lcd_writel(fbi, DB9000_ISR, isr);
+	return IRQ_HANDLED;
+}
+
+/*
+ * This function must be called from task context only, since it will sleep when
+ * disabling the LCD controller, or if we get two contending processes trying to
+ * alter state.
+ */
+static void set_ctrlr_state(struct db9000fb_info *fbi, u_int state)
+{
+	u_int old_state;
+
+	mutex_lock(&fbi->ctrlr_lock);
+	old_state = fbi->state;
+
+	/* Hack around fbcon initialisation. */
+	if (old_state == C_STARTUP && state == C_REENABLE)
+		state = C_STARTUP;
+
+	switch (state) {
+	case C_DISABLE_CLKCHANGE:
+		/*
+		 * Disable controller for clock change. If the controller is
+		 * already disabled, then do nothing.
+		 */
+		if (old_state != C_DISABLE && old_state != C_DISABLE_PM) {
+			db9000fb_backlight_power(fbi, 0);
+			db9000fb_lcd_power(fbi, 0);
+			db9000fb_setup_gpio(fbi, false);
+			fbi->state = state;
+			db9000fb_disable_controller(fbi);
+		}
+		break;
+
+	case C_DISABLE_PM:
+	case C_DISABLE:
+		/* Disable controller */
+		if (old_state != C_DISABLE) {
+			fbi->state = state;
+			db9000fb_backlight_power(fbi, 0);
+			db9000fb_lcd_power(fbi, 0);
+			db9000fb_setup_gpio(fbi, false);
+			if (old_state != C_DISABLE_CLKCHANGE)
+				db9000fb_disable_controller(fbi);
+		}
+		break;
+
+	case C_ENABLE_CLKCHANGE:
+		/*
+		 * Enable the controller after clock change. Only do this if we
+		 * were disabled for the clock change.
+		 */
+		if (old_state == C_DISABLE_CLKCHANGE) {
+			fbi->state = C_ENABLE;
+			db9000fb_setup_gpio(fbi, true);
+			db9000fb_lcd_power(fbi, 1);
+			db9000fb_enable_controller(fbi);
+			/* TODO __db9000fb_lcd_power(fbi, 1); */
+		}
+		break;
+
+	case C_REENABLE:
+		/*
+		 * Re-enable the controller only if it was already enabled.
+		 * This is so we reprogram the control registers.
+		 */
+		if (old_state == C_ENABLE) {
+			db9000fb_backlight_power(fbi, 0);
+			db9000fb_lcd_power(fbi, 0);
+			db9000fb_setup_gpio(fbi, false);
+			db9000fb_disable_controller(fbi);
+			msleep(100);
+			db9000fb_setup_gpio(fbi, true);
+			db9000fb_lcd_power(fbi, 1);
+			db9000fb_enable_controller(fbi);
+			db9000fb_backlight_power(fbi, 1);
+		}
+		break;
+
+	case C_ENABLE_PM:
+		/*
+		 * Re-enable the controller after PM. This is not perfect -
+		 * think about the case where we were doing a clock change, and
+		 * we suspended half-way through.
+		 */
+		if (old_state != C_DISABLE_PM)
+			break;
+		/* fall through */
+
+	case C_ENABLE:
+		/*
+		 * Power up the LCD screen, enable controller, and turn on the
+		 * backlight.
+		 */
+		if (old_state != C_ENABLE) {
+
+			fbi->state = C_ENABLE;
+			db9000fb_setup_gpio(fbi, true);
+			db9000fb_lcd_power(fbi, 1);
+			db9000fb_enable_controller(fbi);
+			db9000fb_backlight_power(fbi, 1);
+		}
+		break;
+
+	case C_STARTUP:
+		fbi->state = C_STARTUP;
+		db9000fb_setup_gpio(fbi, true);
+		db9000fb_lcd_power(fbi, 1);
+		db9000fb_enable_controller(fbi);
+		db9000fb_backlight_power(fbi, 1);
+		msleep(100);
+		db9000fb_backlight_power(fbi, 0);
+		db9000fb_lcd_power(fbi, 0);
+		db9000fb_setup_gpio(fbi, false);
+		db9000fb_disable_controller(fbi);
+		break;
+	}
+	mutex_unlock(&fbi->ctrlr_lock);
+}
+
+/*
+ * Our LCD controller task (which is called when we blank or unblank) via
+ * keventd.
+ */
+static void db9000fb_task(struct work_struct *work)
+{
+	struct db9000fb_info *fbi =
+		container_of(work, struct db9000fb_info, task);
+	u_int state = xchg(&fbi->task_state, -1);
+
+	set_ctrlr_state(fbi, state);
+}
+
+#ifdef CONFIG_CPU_FREQ
+/*
+ * CPU clock speed change handler. We need to adjust the LCD timing parameters
+ * when the CPU clock is adjusted by the power management subsystem.
+ *
+ * TODO: Determine why f->new != 10*get_lclk_frequency_10khz()
+ */
+static int
+db9000fb_freq_transition(
+	struct notifier_block *nb, unsigned long val, void *data)
+{
+	struct db9000fb_info *fbi = TO_INF(nb, freq_transition);
+	struct fb_var_screeninfo *var = &fbi->fb.var;
+	/* TODO struct cpufreq_freqs *f = data; */
+
+	switch (val) {
+	case CPUFREQ_PRECHANGE:
+		if (!fbi->ignore_cpufreq_notification)
+			set_ctrlr_state(fbi, C_DISABLE_CLKCHANGE);
+		break;
+
+	case CPUFREQ_POSTCHANGE:
+		if (!fbi->ignore_cpufreq_notification) {
+			setup_parallel_timing(fbi, var);
+			set_ctrlr_state(fbi, C_ENABLE_CLKCHANGE);
+		}
+		break;
+	}
+	return 0;
+}
+
+/*
+ * Calculate the minimum period (in picoseconds) between two DMA requests
+ * for the LCD controller. If we hit this, it means we're doing nothing but
+ * LCD DMA.
+ */
+static unsigned int db9000fb_display_dma_period(struct fb_var_screeninfo *var)
+{
+	/*
+	 * Period = pixclock * bits_per_byte * bytes_per_transfer /
+	 * memory_bits_per_pixel;
+	 */
+	return var->pixclock * 8 * 16 / var->bits_per_pixel;
+}
+
+static int
+db9000fb_freq_policy(struct notifier_block *nb, unsigned long val, void *data)
+{
+	struct db9000fb_info *fbi = TO_INF(nb, freq_policy);
+	struct fb_var_screeninfo *var = &fbi->fb.var;
+	struct cpufreq_policy *policy = data;
+
+	switch (val) {
+	case CPUFREQ_ADJUST:
+		pr_debug("min dma period: %d ps, new clock %d kHz\n",
+			db9000fb_display_dma_period(var),
+			policy->max);
+		/* TODO: fill in min/max values */
+		break;
+	}
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PM
+/*
+ * Power management hooks. Note that we won't be called from IRQ context, unlike
+ * the blank functions above, so we may sleep.
+ */
+static int db9000fb_suspend(struct device *dev)
+{
+	struct db9000fb_info *fbi = dev_get_drvdata(dev);
+
+	set_ctrlr_state(fbi, C_DISABLE_PM);
+	return 0;
+}
+
+static int db9000fb_resume(struct device *dev)
+{
+	struct db9000fb_info *fbi = dev_get_drvdata(dev);
+
+	set_ctrlr_state(fbi, C_ENABLE_PM);
+	return 0;
+}
+
+static int db9000fb_thaw(struct device *dev)
+{
+	struct db9000fb_info *fbi = dev_get_drvdata(dev);
+
+	if (!fbi->clk_enabled) {
+		fbi->clk_enabled = true;
+		clk_prepare_enable(fbi->clk);
+	}
+
+	fbi->state = fbi->old_state;
+
+	return 0;
+}
+
+static int db9000fb_freeze(struct device *dev)
+{
+	struct db9000fb_info *fbi = dev_get_drvdata(dev);
+
+	if (fbi->clk_enabled) {
+		fbi->clk_enabled = false;
+		clk_disable_unprepare(fbi->clk);
+	}
+
+	fbi->old_state = fbi->state;
+	fbi->state = C_DISABLE_PM;
+
+	return 0;
+}
+
+static const struct dev_pm_ops db9000fb_pm_ops = {
+	.suspend	= db9000fb_suspend,
+	.resume		= db9000fb_resume,
+	.freeze		= db9000fb_freeze,
+	.thaw		= db9000fb_thaw,
+	.poweroff	= db9000fb_suspend,
+	.restore	= db9000fb_resume,
+};
+#endif
+
+static void *db9000fb_init_fbinfo(struct device *dev,
+	struct db9000fb_info *fbi)
+{
+	fbi->clk = clk_get(dev, NULL);
+	if (IS_ERR(fbi->clk))
+		return NULL;
+
+	strcpy(fbi->fb.fix.id, DRIVER_NAME);
+
+	fbi->dev = dev;
+	fbi->fb.fix.type	= FB_TYPE_PACKED_PIXELS;
+	fbi->fb.fix.type_aux	= 0;
+	fbi->fb.fix.xpanstep	= 0;
+	fbi->fb.fix.ypanstep	= 1;
+	fbi->fb.fix.ywrapstep	= 1;
+	fbi->fb.fix.accel	= FB_ACCEL_NONE;
+
+	fbi->fb.var.nonstd	= 0;
+	fbi->fb.var.activate	= FB_ACTIVATE_NOW;
+	fbi->fb.var.height	= fbi->fb.var.yres;
+	fbi->fb.var.width	= fbi->fb.var.xres;
+	fbi->fb.var.accel_flags	= 0;
+	fbi->fb.var.vmode	= FB_VMODE_NONINTERLACED;
+	fbi->fb.pseudo_palette	= fbi->cmap;
+	fbi->fb.fbops		= &db9000fb_ops;
+	fbi->fb.flags		= FBINFO_DEFAULT;
+	fbi->fb.node		= -1;
+
+	fbi->state		= C_STARTUP;
+	fbi->task_state		= (u_char)-1;
+
+	atomic_set(&fbi->usage, 0);
+	init_waitqueue_head(&fbi->ctrlr_wait);
+	INIT_WORK(&fbi->task, db9000fb_task);
+	mutex_init(&fbi->ctrlr_lock);
+	init_completion(&fbi->vsync_notifier);
+
+	return fbi;
+}
+
+static void get_backlight_pwm_clock(struct device_node *np,
+	struct db9000fb_info *fbi)
+{
+	int ret;
+	u32 pwm_clock;
+
+	ret = of_property_read_u32(np, "backlight-pwm-clock", &pwm_clock);
+	if (!ret)
+		fbi->pwm_clock = pwm_clock;
+}
+
+#if defined(CONFIG_FB_DB9000_BLINK)
+static int setup_blink_mode(struct device_node *np, struct db9000fb_info *fbi)
+{
+	int ret;
+	u32 fast_blink_ms;
+	u32 pwmfcd;
+	u32 blink_duty_cycle;
+	u32 pwmdc;
+
+	if (fbi->fb.var.bits_per_pixel != 24)
+		return 0;
+
+	ret = of_property_read_u32(np, "blink-period-ms", &fast_blink_ms);
+	if (ret)
+		return 0;
+
+	if (fast_blink_ms == 0)
+		return 0;
+
+	/* div = (pclk / 256) * fast blink period */
+	pwmfcd = clk_get_rate(fbi->pixel_clk) / 256;
+	pwmfcd *= fast_blink_ms;
+	pwmfcd /= 1000;	/* adjustment as blink period is in ms */
+
+	ret = of_property_read_u32(np, "blink-duty-cycle",
+					&blink_duty_cycle);
+	if (ret)
+		blink_duty_cycle = 50; /* default % */
+
+	if (blink_duty_cycle > 100)
+		return -EINVAL;
+
+	pwmdc = (blink_duty_cycle * 256) / 100;
+
+	lcd_writel(fbi, DB9000_PWMFR_BLINK,
+		DB9000_PWMFR_PWM_FCD(pwmfcd-1) | DB9000_PWMFR_PWM_FCE);
+	lcd_writel(fbi, DB9000_PWMDCR_BLINK, pwmdc-1);
+	lcd_writel(fbi, DB9000_GPIOR, 1);
+
+	fbi->use_blinking = true;
+
+	return 0;
+}
+#endif
+
+static int db9000fb_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct db9000fb_info *fbi;
+	struct display_timings *disp_timings;
+	struct display_timing *disp_timing;
+	struct fb_videomode mode;
+	u32 bpp;
+	struct device_node *np = pdev->dev.of_node;
+	dma_addr_t fb_mem_phys;
+	unsigned long fb_mem_len;
+	void *fb_mem_virt;
+	struct resource *res;
+	int irq;
+	int ret;
+	const char *def_mode;
+
+	/* Alloc the db9000fb_info with the embedded pseudo_palette */
+	fbi = devm_kzalloc(dev, sizeof(struct db9000fb_info), GFP_KERNEL);
+	if (!fbi)
+		return -ENOMEM;
+
+	disp_timings = of_get_display_timings(np);
+	if (!disp_timings)
+		return -EINVAL;
+
+	ret = of_get_fb_videomode(np, &mode, OF_USE_NATIVE_MODE);
+	if (ret) {
+		dev_err(dev, "Could not get videomode\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(np, "bits-per-pixel", &bpp);
+	if (ret) {
+		dev_err(dev, "Required bits-per-pixel property is missing\n");
+		return ret;
+	}
+
+	/* setup the timing properties */
+	disp_timing = disp_timings->timings[disp_timings->native_mode];
+	if (disp_timing->flags & DISPLAY_FLAGS_HSYNC_LOW)
+		fbi->reg_cr1 |= DB9000_CR1_HSP;
+	if (disp_timing->flags & DISPLAY_FLAGS_VSYNC_LOW)
+		fbi->reg_cr1 |= DB9000_CR1_VSP;
+	if (disp_timing->flags & DISPLAY_FLAGS_DE_HIGH)
+		fbi->reg_cr1 |= DB9000_CR1_DEP;
+
+	/* Width of RGB data going to the panel */
+	ret = of_property_read_u32(np, "bus-width", &fbi->buswidth);
+	if (ret)
+		fbi->buswidth = 24;
+
+	/* Request 16 beat burst Master Bus transactions for max performance */
+	fbi->reg_cr1 |= DB9000_CR1_FDW(2);
+
+#ifdef CONFIG_BACKLIGHT_DB9000_LCD
+	fbi->reg_pwmdcr = DEF_BRIGHTNESS;
+#endif
+
+	/* Pixel clock */
+	fbi->pixel_clk = devm_clk_get(dev, "pclk");
+	if (IS_ERR(fbi->pixel_clk))
+		return PTR_ERR(fbi->pixel_clk);
+	ret = clk_prepare_enable(fbi->pixel_clk);
+	if (ret) {
+		dev_err(dev, "Failed to enable pixel clock\n");
+		return ret;
+	}
+
+	/* AHB bus clock */
+	fbi->bus_clk = devm_clk_get(dev, "ahb");
+	if (IS_ERR(fbi->bus_clk))
+		return PTR_ERR(fbi->bus_clk);
+	ret = clk_prepare_enable(fbi->bus_clk);
+	if (ret) {
+		dev_err(dev, "Failed to enable AHB clock\n");
+		return ret;
+	}
+
+	/* allocate the framebuffer. Worst case bpp in case changed later on */
+	fbi->frame_size = (mode.xres * mode.yres * 32) / 8;
+	fb_mem_len = fbi->frame_size * NUM_OF_FRAMEBUFFERS;
+
+	fb_mem_virt = dmam_alloc_coherent(dev, fb_mem_len, &fb_mem_phys,
+				GFP_KERNEL);
+	if (!fb_mem_virt) {
+		dev_err(dev, "Failed to allocate framebuffer\n");
+		return -ENOMEM;
+	}
+
+	db9000fb_init_fbinfo(dev, fbi);
+
+	/* registers */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -EINVAL;
+
+	fbi->mmio_base = devm_ioremap_resource(dev, res);
+	if (!fbi->mmio_base) {
+		dev_err(dev, "failed to map I/O memory\n");
+		return -ENOMEM;
+	}
+
+	/* irq */
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(dev, "no IRQ defined\n");
+		return -ENOENT;
+	}
+
+	ret = devm_request_irq(dev, irq, db9000fb_handle_irq, 0, pdev->name,
+			       fbi);
+	if (ret) {
+		dev_err(dev, "request_irq failed: %d\n", ret);
+		return ret;
+	}
+
+	/* pins */
+	fbi->pinctrl = devm_pinctrl_get(dev);
+	if (IS_ERR(fbi->pinctrl))
+		ret = PTR_ERR(fbi->pinctrl);
+
+	fbi->pins_default = pinctrl_lookup_state(fbi->pinctrl,
+			PINCTRL_STATE_DEFAULT);
+	if (IS_ERR(fbi->pins_default))
+		dev_err(dev, "could not get default pinstate\n");
+
+	fbi->pins_sleep = pinctrl_lookup_state(fbi->pinctrl,
+			PINCTRL_STATE_SLEEP);
+	if (IS_ERR(fbi->pins_sleep))
+		dev_dbg(dev, "could not get sleep pinstate\n");
+
+	/* other */
+	if (np) {
+		of_property_read_string(np, "st,mode", &def_mode);
+
+		if (of_get_property(np, "ignore_cpufreq_notification", NULL))
+			fbi->ignore_cpufreq_notification = true;
+	}
+
+	if (!mode_option)
+		mode_option = def_mode;
+
+	fb_videomode_to_var(&fbi->fb.var, &mode);
+
+	dev_info(dev, "got a %dx%dx%d LCD\n", fbi->fb.var.xres,
+			fbi->fb.var.yres, bpp);
+
+	/* Initialize fb_info */
+	fbi->pdev = pdev;
+	fbi->fb.screen_base	= fb_mem_virt;
+	fbi->fb.fix.smem_start	= fb_mem_phys;
+	fbi->fb.fix.smem_len	= fb_mem_len;
+	fbi->fb.var.height	= fbi->fb.var.yres;
+	fbi->fb.var.width	= fbi->fb.var.xres;
+	fbi->fb.var.bits_per_pixel = bpp;
+
+	get_backlight_pwm_clock(np, fbi);
+
+#if defined(CONFIG_FB_DB9000_BLINK)
+	ret = setup_blink_mode(np, fbi);
+	if (ret) {
+		dev_err(dev, "Failed to set blink parameters\n");
+		return ret;
+	}
+#endif
+
+	ret = db9000fb_check_var(&fbi->fb.var, &fbi->fb);
+	if (ret) {
+		dev_err(dev, "failed to get suitable mode\n");
+		goto err_free_bl;
+	}
+
+	platform_set_drvdata(pdev, fbi);
+
+	ret = register_framebuffer(&fbi->fb);
+	if (ret < 0) {
+		dev_err(dev, "Failed to register framebuffer device:%d\n", ret);
+		goto err_clear_plat_data;
+	}
+
+#ifdef CONFIG_CPU_FREQ
+	fbi->freq_transition.notifier_call = db9000fb_freq_transition;
+	fbi->freq_policy.notifier_call = db9000fb_freq_policy;
+	cpufreq_register_notifier(&fbi->freq_transition,
+			CPUFREQ_TRANSITION_NOTIFIER);
+	cpufreq_register_notifier(&fbi->freq_policy,
+			CPUFREQ_POLICY_NOTIFIER);
+#endif
+
+	/* Read the core version register and print it out */
+	fbi->db9000_rev = lcd_readl(fbi, DB9000_CIR);
+	dev_info(dev, "Core ID reg: 0x%08X\n", fbi->db9000_rev);
+
+	ret = db9000fb_set_par(&fbi->fb);
+	if (ret) {
+		dev_err(dev, "Failed to set parameters\n");
+		goto err_clear_plat_data;
+	}
+
+	return 0;
+
+err_clear_plat_data:
+	platform_set_drvdata(pdev, NULL);
+	if (fbi->fb.cmap.len)
+		fb_dealloc_cmap(&fbi->fb.cmap);
+err_free_bl:
+	clk_put(fbi->clk);
+
+	return ret;
+}
+
+static int db9000fb_remove(struct platform_device *pdev)
+{
+	struct db9000fb_info *fbi = platform_get_drvdata(pdev);
+	struct fb_info *info;
+
+	if (!fbi)
+		return 0;
+
+	info = &fbi->fb;
+
+	unregister_framebuffer(info);
+	db9000fb_disable_controller(fbi);
+	complete_and_exit(&fbi->vsync_notifier, 0);
+
+	if (fbi->fb.cmap.len)
+		fb_dealloc_cmap(&fbi->fb.cmap);
+
+	clk_put(fbi->clk);
+
+	return 0;
+}
+
+static const struct of_device_id db9000fb_id_match[] = {
+	{ .compatible = "digitalblocks,db9000-clcd", },
+	{}
+};
+
+static struct platform_driver db9000fb_driver = {
+	.probe		= db9000fb_probe,
+	.remove		= db9000fb_remove,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= DRIVER_NAME,
+		.of_match_table = db9000fb_id_match,
+#ifdef CONFIG_PM
+		.pm = &db9000fb_pm_ops,
+#endif
+	},
+};
+
+#ifndef MODULE
+static int __init db9000fb_setup(char *options)
+{
+	char *this_opt;
+
+	/* Parse user speficied options (`video=db9000:') */
+	if (!options || !*options)
+		return 0;
+
+	while ((this_opt = strsep(&options, ",")) != NULL) {
+		if (!*this_opt)
+			continue;
+		else
+			mode_option = this_opt;
+	}
+	return 0;
+}
+#endif
+
+static int __init db9000fb_init(void)
+{
+	/* For kernel boot options (in 'video=pm3fb:<options>' format) */
+#ifndef MODULE
+	char *option = NULL;
+
+	if (fb_get_options("db9000", &option))
+		return -ENODEV;
+	db9000fb_setup(option);
+#endif
+	return platform_driver_register(&db9000fb_driver);
+}
+module_init(db9000fb_init);
+
+static void __exit db9000fb_exit(void)
+{
+	platform_driver_unregister(&db9000fb_driver);
+}
+module_exit(db9000fb_exit);
+
+MODULE_DESCRIPTION("loadable framebuffer driver for Digital Blocks DB9000");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/fbdev/db9000fb.h b/drivers/video/fbdev/db9000fb.h
new file mode 100644
index 0000000..7184f18
--- /dev/null
+++ b/drivers/video/fbdev/db9000fb.h
@@ -0,0 +1,234 @@
+/*
+ * linux/drivers/video/db9000fb.h
+ *    -- Digital Blocks DB9000 LCD Controller Frame Buffer Device
+ * Copyright (C) 2016 Renesas Electronics Europe Ltd.
+ * Copyright (C) 2010 Digital Blocks, Inc.
+ *
+ * Based on pxafb.h
+ * Copyright (C) 1999 Eric A. Thomas.
+ * Copyright (C) 2004 Jean-Frederic Clere.
+ * Copyright (C) 2004 Ian Campbell.
+ * Copyright (C) 2004 Jeff Lackey.
+ * Based on sa1100fb.c Copyright (C) 1999 Eric A. Thomas
+ * which in turn is
+ * Based on acornfb.c Copyright (C) Russell King.
+ *
+ *  2001-08-03: Cliff Brake <cbrake@acclent.com>
+ *	 - ported SA1100 code to PXA
+ *  2010-05-01: Guy Winter <gwinter@digitalblocks.com>
+ *  - ported pxafb code to DB9000
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+
+#ifndef __DB9000FB_H__
+#define __DB9000FB_H__
+
+/* LCD Controller Control Register 1 */
+#define DB9000_CR1	(0x000)
+/* Horizontal Timing Register */
+#define DB9000_HTR	(0x008)
+/* Vertical Timing Register 1 */
+#define DB9000_VTR1	(0x00C)
+/* Vertical Timing Register 2 */
+#define DB9000_VTR2	(0x010)
+/* Pixel Clock Timing Register */
+#define DB9000_PCTR	(0x014)
+/* Interrupt Status Register */
+#define DB9000_ISR	(0x018)
+/* Interrupt Mask Register */
+#define DB9000_IMR	(0x01C)
+/* Interrupt Vector Register */
+#define DB9000_IVR	(0x020)
+/* Interrupt Scan Compare Register */
+#define DB9000_ISCR	(0x024)
+/* DMA Base Address Register */
+#define DB9000_DBAR	(0x028)
+/* DMA Current Address Register */
+#define DB9000_DCAR	(0x02C)
+/* DMA End Address Register */
+#define DB9000_DEAR	(0x030)
+/* PWM Frequency Register */
+#if defined(CONFIG_FB_DB9000_BLINK)
+#define DB9000_PWMFR	(0x04c)
+#define DB9000_PWMFR_BLINK	(0x034)
+#else
+#define DB9000_PWMFR	(0x034)
+#endif
+/* PWM Duty Cycle Register */
+#if defined(CONFIG_FB_DB9000_BLINK)
+#define DB9000_PWMDCR	(0x050)
+#define DB9000_PWMDCR_BLINK	(0x038)
+#else
+#define DB9000_PWMDCR	(0x038)
+#endif
+/* DMA Frame Descriptor Branch Address Register */
+#define DB9000_DFBAR	(0x03C)
+/* DMA Frame Descriptor Last Address Register */
+#define DB9000_DFLAR	(0x040)
+/* DMA Horizontal and Vertical Timing Extension Register */
+#define DB9000_HVTER	(0x044)
+/* GPIO Register */
+#define DB9000_GPIOR	(0x1F8)
+/* Core Identification Register */
+#define DB9000_CIR	(0x1FC)
+/* Palette Data Words */
+#define DB9000_PALT	(0x200)
+
+/* Multiple Memory Reads Request Register */
+#define DB9000_MRR	(0xFFC)
+
+/* Control Register 1, Offset 0x000 */
+/* LCD Controller Enable */
+#define DB9000_CR1_ENB		(1 << 0)
+/* LCD Power Enable */
+#define DB9000_CR1_LPE		(1 << 1)
+/* LCD Bits per Pixel */
+#define DB9000_CR1_BPP(x)	(((x) & 0x7) << 2)
+/* RGB or BGR Format */
+#define DB9000_CR1_RGB		(1 << 5)
+/* Big or Little Endian Pixel Ordering */
+#define DB9000_CR1_EPO		(1 << 6)
+/* Big or Little Endian Byte Ordering  */
+#define DB9000_CR1_EBO		(1 << 7)
+/* Data Enable Polarity */
+#define DB9000_CR1_DEP		(1 << 8)
+/* Pixel Clock Polarity */
+#define DB9000_CR1_PCP		(1 << 9)
+/* Horizontal Sync Polarity */
+#define DB9000_CR1_HSP		(1 << 10)
+/* Vertical Sync Polarity */
+#define DB9000_CR1_VSP		(1 << 11)
+/* Output Pixel Select */
+#define DB9000_CR1_OPS(x)	(((x) & 0x7) << 12)
+/* FIFO DMA Request Words */
+#define DB9000_CR1_FDW(x)	(((x) & 0x3) << 16)
+/* LCD 1 or Port Select */
+#define DB9000_CR1_LPS		(1 << 18)
+/* Frame Buffer 24bpp Packed Word */
+#define DB9000_CR1_FBP		(1 << 19)
+/* DMA End Address Enable */
+#define DB9000_CR1_DEE		(1 << 20)
+/* 1 bit per pixel */
+#define DB9000_CR1_BPP_1bpp	(0)
+/* 2 bits per pixel */
+#define DB9000_CR1_BPP_2bpp	(1)
+/* 4 bits per pixel */
+#define DB9000_CR1_BPP_4bpp	(2)
+/* 8 bits per pixel */
+#define DB9000_CR1_BPP_8bpp	(3)
+/* 16 bits per pixel */
+#define DB9000_CR1_BPP_16bpp	(4)
+/* 18 bits per pixel */
+#define DB9000_CR1_BPP_18bpp	(5)
+/* 24 bits per pixel */
+#define DB9000_CR1_BPP_24bpp	(6)
+/*  Pixel clock Rising-Edge */
+#define DB9000_CR1_PixRsEdg	(DB9000_CR1_PCP*0)
+/*  Pixel clock Falling-Edge */
+#define DB9000_CR1_PixFlEdg	(DB9000_CR1_PCP*1)
+
+/* Horizontal Timing Register, Offset 0x008 */
+/* Horizontal Front Porch */
+#define DB9000_HTR_HFP(x)	(((x) & 0xff) << 0)
+/* Pixels per Line */
+#define DB9000_HTR_PPL(x)	(((x) & 0xff) << 8)
+/* Horizontal Back Porch */
+#define DB9000_HTR_HBP(x)	(((x) & 0xff) << 16)
+/* Horizontal Sync Width */
+#define DB9000_HTR_HSW(x)	(((x) & 0xff) << 24)
+
+/* Vertical Timing Register 1, Offset 0x00C */
+/* Vertical Sync Width */
+#define DB9000_VTR1_VSW(x)	(((x) & 0xff) << 0)
+/* Vertical Front Porch */
+#define DB9000_VTR1_VFP(x)	(((x) & 0xff) << 8)
+/* Vertical Back Porch */
+#define DB9000_VTR1_VBP(x)	(((x) & 0xff) << 16)
+
+/* Vertical and Horizontal Timing Extension Register, Offset 0x044 */
+/* Horizontal Front Porch Extension */
+#define DB9000_HVTER_HFPE(x)	((((x) >> 8) & 0x3) << 0)
+/* Horizontal Back Porch Extension */
+#define DB9000_HVTER_HBPE(x)	((((x) >> 8) & 0x3) << 4)
+/* Vertical Front Porch Extension */
+#define DB9000_HVTER_VFPE(x)	((((x) >> 8) & 0x3) << 8)
+/* Vertical Back Porch Extension */
+#define DB9000_HVTER_VBPE(x)	((((x) >> 8) & 0x3) << 12)
+
+/* DB9000 Revisions */
+#define DB9000_REVISION_1_14	(0x0E)
+
+/* Vertical Timing Register 2, Offset 0x010 */
+/* Lines Per Panel */
+#define DB9000_VTR2_LPP(x)	(((x) & 0xfff) << 0)
+
+/* Pixel Clock Timing Register, Offset 0x014 */
+/* Pixel Clock Divider */
+#define DB9000_PCTR_PCD(x)	(((x) & 0xff) << 0)
+/* Pixel Clock Divider Bypass */
+#define DB9000_PCTR_PCB		(1 << 8)
+/* Pixel Clock Input Select */
+#define DB9000_PCTR_PCI		(1 << 9)
+/* clock reset select */
+#define DB9000_PCTR_PCR		(1 << 10)
+
+/* Interrupt Status Register, Offset 0x018 */
+#define DB9000_ISR_OFU	(1 << 0) /* Output FIFO Underrun */
+#define DB9000_ISR_OFO	(1 << 1) /* Output FIFO Overrun */
+#define DB9000_ISR_IFU	(1 << 2) /* Input FIFO Underrun */
+#define DB9000_ISR_IFO	(1 << 3) /* Input FIFO Overrun */
+#define DB9000_ISR_FER	(1 << 4) /* OR of OFU, OFO, IFU, IFO */
+#define DB9000_ISR_MBE	(1 << 5) /* Master Bus Error */
+#define DB9000_ISR_VCT	(1 << 6) /* Vertical Compare Triggered */
+#define DB9000_ISR_BAU	(1 << 7) /* DMA Base Address Register Update to CAR */
+#define DB9000_ISR_LDD	(1 << 8) /* LCD Controller Disable Done */
+
+#define DB9000_ISR_ABL	(1 << 9) /* AXI Master - Read Burst Length Error */
+#define DB9000_ISR_ARI	(1 << 10) /* AXI Master - Return ID Error */
+#define DB9000_ISR_ARS	(1 << 11) /* AXI Master - Response Signal Error */
+
+#define DB9000_ISR_FBE	(1 << 12) /* Frame Descriptor - Bus Error */
+#define DB9000_ISR_FNC	(1 << 13) /* Frame Descriptor - Node Complete */
+#define DB9000_ISR_FLC	(1 << 14) /* Frame Descriptor - List Complete */
+
+/* Interrupt Mask Register, Offset 0x01C */
+#define DB9000_ISR_OFUM	(1 << 0)  /* Output FIFO Underrun - Mask */
+#define DB9000_ISR_OFOM	(1 << 1)  /* Output FIFO Overrun - Mask */
+#define DB9000_ISR_IFUM	(1 << 2)  /* Input FIFO Underrun - Mask */
+#define DB9000_ISR_IFOM	(1 << 3)  /* Input FIFO Overrun - Mask */
+#define DB9000_ISR_FERM	(1 << 4)  /* OR of OFU, OFO, IFU, IFO - Mask */
+#define DB9000_ISR_MBEM	(1 << 5)  /* Master Bus Error - Mask */
+#define DB9000_ISR_VCTM	(1 << 6)  /* Vertical Compare Triggered - Mask */
+/* DMA Base Address Register Update to CAR - Mask */
+#define DB9000_ISR_BAUM	(1 << 7)
+#define DB9000_ISR_LDDM	(1 << 8)  /* LCD Controller Disable Done - Mask */
+
+/* AXI Master - Read Burst Length Error - Mask */
+#define DB9000_ISR_ABLM	(1 << 9)
+/* AXI Master - Return ID Error - Mask */
+#define DB9000_ISR_ARIM	(1 << 10)
+/* AXI Master - Response Signal Error - Mask */
+
+#define DB9000_ISR_ARSM	(1 << 11)
+#define DB9000_ISR_FBEM	(1 << 12) /* Frame Descriptor - Bus Error - Mask */
+#define DB9000_ISR_FNCM	(1 << 13) /* Frame Descriptor - Node Complete - Mask */
+#define DB9000_ISR_FLCM	(1 << 14) /* Frame Descriptor - List Complete - Mask */
+
+/* PWM Frequency Registers, Offset 0x034 and 0x04c */
+#define DB9000_PWMFR_PWM_FCD(x)	(((x) & 0x3fffff) << 0)
+#define DB9000_PWMFR_PWM_FCE	(1 << 22)
+
+/* PWM Duty Cycle Registers, Offset 0x038 and 0x050 */
+#define DB9000_PWMDCR_DCR(x)	((x) & 0xff)
+
+/* Multiple Memory Reads Request Register, offset 0xFFC */
+#define DB9000_MRR_MRR(x)	(((x) & 0x3) << 0)
+#define DB9000_MRR_DEAR_MRR(x)	((x) & 0xFFFFFFFC)
+#define DB9000_MRR_OUTST_0	0x0
+#define DB9000_MRR_OUTST_2	0x1
+#define DB9000_MRR_OUTST_4	0x2
+
+#endif /* __DB9000FB_H__ */
-- 
2.7.4

